# COMBO-10: AI ì½”ì¹˜ í†µí•© ì‘ë‹µ (AI Coach Integrated Response)

> í¬ë¡œìŠ¤ë„ë©”ì¸ ë¶„ì„ 10/10 - ë‹¤ì¤‘ ëª¨ë“ˆ ë°ì´í„°ë¥¼ í†µí•©í•œ AI ì›°ë‹ˆìŠ¤ ì½”ì¹˜ ì‹œìŠ¤í…œ

---

## 1. ì—°êµ¬ ê°œìš”

### 1.1 ëª©ì 

í”¼ë¶€, ì˜ì–‘, ìš´ë™, ì²´í˜•, í¼ìŠ¤ë„ì»¬ëŸ¬ ë“± ëª¨ë“  ë¶„ì„ ë°ì´í„°ë¥¼ í†µí•©í•˜ì—¬:
- **ë§ì¶¤í˜• ì¡°ì–¸** ì œê³µ
- **ëŒ€í™”í˜• ì¸í„°í˜ì´ìŠ¤** êµ¬í˜„
- **ì‹¤ì‹œê°„ ì§ˆì˜ì‘ë‹µ** ì§€ì›
- **í†µí•©ì  ì›°ë‹ˆìŠ¤ ê°€ì´ë“œ** ì—­í• 

### 1.2 ì‹œì¥ ë™í–¥ (2025)

| ì„œë¹„ìŠ¤ | íŠ¹ì§• | AI ê¸°ìˆ  |
|--------|------|---------|
| **Fitbit AI Coach** | Gemini ê¸°ë°˜ ëŒ€í™”í˜• ì½”ì¹˜ | Google Gemini |
| **WHOOP Coach** | ì‹¤ì‹œê°„ í”¼ë“œë°±, ìˆ˜ë©´ ìµœì í™” | GPT ê³„ì—´ |
| **Apple Fitness+** | ìš´ë™ ì¶”ì²œ, ë™ê¸°ë¶€ì—¬ | On-device ML |
| **Noom** | ì‹¬ë¦¬ ê¸°ë°˜ í–‰ë™ ë³€í™” | NLP + CBT |

### 1.3 í•µì‹¬ ì§ˆë¬¸

| ì§ˆë¬¸ | ë‹µë³€ ë°©í–¥ |
|------|----------|
| ì–´ë–¤ AI ëª¨ë¸? | Gemini 3 Flash (ê¸°ì¡´ ì¸í”„ë¼ í™œìš©) |
| ëŒ€í™” ì»¨í…ìŠ¤íŠ¸? | ëª¨ë“  ëª¨ë“ˆ ë¶„ì„ ê²°ê³¼ í†µí•© |
| ì‘ë‹µ ìŠ¤íƒ€ì¼? | ì¹œê·¼í•˜ê³  ì „ë¬¸ì ì¸ í•œêµ­ì–´ |
| ê°œì¸í™” ìˆ˜ì¤€? | ì‚¬ìš©ì í”„ë¡œí•„ + ë¶„ì„ íˆìŠ¤í† ë¦¬ ê¸°ë°˜ |

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      AI ì½”ì¹˜ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   ì‚¬ìš©ì ì§ˆë¬¸                                                    â”‚
â”‚       â†“                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ë ˆì´ì–´                         â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
â”‚   â”‚  â”‚ í”¼ë¶€    â”‚ â”‚ ì˜ì–‘    â”‚ â”‚ ìš´ë™    â”‚ â”‚ ì²´í˜•    â”‚ ...   â”‚   â”‚
â”‚   â”‚  â”‚ ë¶„ì„    â”‚ â”‚ ë°ì´í„°  â”‚ â”‚ ê¸°ë¡    â”‚ â”‚ ë¶„ì„    â”‚       â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â†“                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ë ˆì´ì–´                   â”‚   â”‚
â”‚   â”‚  - ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ (ì½”ì¹˜ í˜ë¥´ì†Œë‚˜)                       â”‚   â”‚
â”‚   â”‚  - ì»¨í…ìŠ¤íŠ¸ ì£¼ì… (ì‚¬ìš©ì ë°ì´í„°)                         â”‚   â”‚
â”‚   â”‚  - ì§ˆë¬¸ ë¶„ë¥˜ (intent detection)                         â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â†“                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              Gemini 3 Flash API                          â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â†“                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              ì‘ë‹µ í›„ì²˜ë¦¬ ë ˆì´ì–´                           â”‚   â”‚
â”‚   â”‚  - ì‘ë‹µ ê²€ì¦ (ì•ˆì „ì„±, ì˜ë£Œ ë©´ì±…)                         â”‚   â”‚
â”‚   â”‚  - ì•¡ì…˜ ì¶”ì¶œ (ì¶”ì²œ í–‰ë™)                                 â”‚   â”‚
â”‚   â”‚  - í¬ë§·íŒ… (ë§ˆí¬ë‹¤ìš´, ì´ëª¨ì§€)                             â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â†“                                                         â”‚
â”‚   AI ì½”ì¹˜ ì‘ë‹µ                                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ë°ì´í„° íƒ€ì… ì •ì˜

```typescript
// types/ai-coach.ts

export interface UserContext {
  profile: UserProfile;
  analyses: AnalysisSummaries;
  recentActivities: RecentActivity[];
  goals: UserGoal[];
  preferences: UserPreferences;
}

export interface UserProfile {
  userId: string;
  nickname?: string;
  age?: number;
  gender?: 'male' | 'female' | 'other';
  memberSince: Date;
}

export interface AnalysisSummaries {
  skin?: SkinSummary;
  nutrition?: NutritionSummary;
  fitness?: FitnessSummary;
  bodyType?: BodyTypeSummary;
  personalColor?: PersonalColorSummary;
  posture?: PostureSummary;
}

export interface SkinSummary {
  skinType: string;
  mainConcerns: string[];
  recentTrend: 'improving' | 'declining' | 'stable';
  lastAnalysisDate: Date;
  hydrationScore: number;
  overallScore: number;
}

export interface NutritionSummary {
  nutritionScore: number;
  deficiencies: string[];
  recentCalories: number;
  waterIntake: number;
  recommendations: string[];
}

export interface FitnessSummary {
  weeklyWorkouts: number;
  preferredExercises: string[];
  recentCaloriesBurned: number;
  activeMinutes: number;
  trend: 'increasing' | 'decreasing' | 'stable';
}

export interface BodyTypeSummary {
  bodyType: string;
  posture: string;
  targetAreas: string[];
}

export interface PersonalColorSummary {
  season: string;
  subSeason: string;
  bestColors: string[];
  avoidColors: string[];
}

export interface CoachMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: {
    intent?: string;
    relatedModules?: string[];
    suggestedActions?: SuggestedAction[];
  };
}

export interface SuggestedAction {
  type: 'navigate' | 'log' | 'reminder' | 'learn';
  label: string;
  target: string;
  priority: 'high' | 'medium' | 'low';
}

export interface CoachResponse {
  message: string;
  suggestedActions?: SuggestedAction[];
  relatedTopics?: string[];
  disclaimer?: string;
}
```

---

## 3. ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘

### 3.1 í†µí•© ì»¨í…ìŠ¤íŠ¸ ë¹Œë”

```typescript
// lib/ai-coach/context-builder.ts

import { SupabaseClient } from '@supabase/supabase-js';
import { UserContext, AnalysisSummaries } from '@/types/ai-coach';

export async function buildUserContext(
  supabase: SupabaseClient,
  userId: string
): Promise<UserContext> {
  // ë³‘ë ¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ
  const [
    profile,
    skinAnalysis,
    nutritionData,
    fitnessData,
    bodyTypeData,
    personalColorData,
    postureData,
    recentActivities,
    goals,
    preferences,
  ] = await Promise.all([
    getUserProfile(supabase, userId),
    getLatestSkinAnalysis(supabase, userId),
    getLatestNutritionData(supabase, userId),
    getLatestFitnessData(supabase, userId),
    getLatestBodyTypeData(supabase, userId),
    getLatestPersonalColorData(supabase, userId),
    getLatestPostureData(supabase, userId),
    getRecentActivities(supabase, userId, 7), // ìµœê·¼ 7ì¼
    getUserGoals(supabase, userId),
    getUserPreferences(supabase, userId),
  ]);

  return {
    profile,
    analyses: {
      skin: skinAnalysis ? summarizeSkinAnalysis(skinAnalysis) : undefined,
      nutrition: nutritionData ? summarizeNutrition(nutritionData) : undefined,
      fitness: fitnessData ? summarizeFitness(fitnessData) : undefined,
      bodyType: bodyTypeData ? summarizeBodyType(bodyTypeData) : undefined,
      personalColor: personalColorData ? summarizePersonalColor(personalColorData) : undefined,
      posture: postureData ? summarizePosture(postureData) : undefined,
    },
    recentActivities,
    goals,
    preferences,
  };
}

// í”¼ë¶€ ë¶„ì„ ìš”ì•½
function summarizeSkinAnalysis(analysis: any): SkinSummary {
  return {
    skinType: analysis.skin_type,
    mainConcerns: analysis.concerns || [],
    recentTrend: analysis.trend || 'stable',
    lastAnalysisDate: new Date(analysis.created_at),
    hydrationScore: analysis.scores?.hydration || 0,
    overallScore: analysis.overall_score || 0,
  };
}

// ì˜ì–‘ ë°ì´í„° ìš”ì•½
function summarizeNutrition(data: any): NutritionSummary {
  const recent = data.recent_logs || [];
  const avgCalories = recent.length > 0
    ? recent.reduce((sum: number, log: any) => sum + log.calories, 0) / recent.length
    : 0;

  return {
    nutritionScore: data.score || 0,
    deficiencies: data.deficiencies || [],
    recentCalories: Math.round(avgCalories),
    waterIntake: data.water_intake || 0,
    recommendations: data.recommendations || [],
  };
}

// ìš´ë™ ë°ì´í„° ìš”ì•½
function summarizeFitness(data: any): FitnessSummary {
  return {
    weeklyWorkouts: data.weekly_count || 0,
    preferredExercises: data.preferred_exercises || [],
    recentCaloriesBurned: data.calories_burned || 0,
    activeMinutes: data.active_minutes || 0,
    trend: data.trend || 'stable',
  };
}
```

### 3.2 ì»¨í…ìŠ¤íŠ¸ ì§ë ¬í™”

```typescript
// lib/ai-coach/context-serializer.ts

export function serializeContextForPrompt(context: UserContext): string {
  const parts: string[] = [];

  // í”„ë¡œí•„ ì •ë³´
  parts.push(`## ì‚¬ìš©ì í”„ë¡œí•„`);
  if (context.profile.nickname) {
    parts.push(`- ë‹‰ë„¤ì„: ${context.profile.nickname}`);
  }
  if (context.profile.age) {
    parts.push(`- ì—°ë ¹ëŒ€: ${getAgeGroup(context.profile.age)}`);
  }
  parts.push(`- ê°€ì… ê¸°ê°„: ${getDaysSince(context.profile.memberSince)}ì¼`);

  // ë¶„ì„ ìš”ì•½
  if (context.analyses.skin) {
    parts.push(`\n## í”¼ë¶€ ìƒíƒœ`);
    parts.push(`- í”¼ë¶€ íƒ€ì…: ${context.analyses.skin.skinType}`);
    parts.push(`- ì£¼ìš” ê³ ë¯¼: ${context.analyses.skin.mainConcerns.join(', ') || 'ì—†ìŒ'}`);
    parts.push(`- ìˆ˜ë¶„ ì ìˆ˜: ${context.analyses.skin.hydrationScore}/100`);
    parts.push(`- ìµœê·¼ ì¶”ì„¸: ${translateTrend(context.analyses.skin.recentTrend)}`);
  }

  if (context.analyses.nutrition) {
    parts.push(`\n## ì˜ì–‘ ìƒíƒœ`);
    parts.push(`- ì˜ì–‘ ì ìˆ˜: ${context.analyses.nutrition.nutritionScore}/100`);
    parts.push(`- ë¶€ì¡± ì˜ì–‘ì†Œ: ${context.analyses.nutrition.deficiencies.join(', ') || 'ì—†ìŒ'}`);
    parts.push(`- í‰ê·  ì¹¼ë¡œë¦¬: ${context.analyses.nutrition.recentCalories}kcal/ì¼`);
  }

  if (context.analyses.fitness) {
    parts.push(`\n## ìš´ë™ í˜„í™©`);
    parts.push(`- ì£¼ê°„ ìš´ë™: ${context.analyses.fitness.weeklyWorkouts}íšŒ`);
    parts.push(`- ì„ í˜¸ ìš´ë™: ${context.analyses.fitness.preferredExercises.join(', ') || 'ë¯¸ì •'}`);
    parts.push(`- í™œë™ëŸ‰ ì¶”ì„¸: ${translateTrend(context.analyses.fitness.trend)}`);
  }

  if (context.analyses.personalColor) {
    parts.push(`\n## í¼ìŠ¤ë„ì»¬ëŸ¬`);
    parts.push(`- ì‹œì¦Œ: ${context.analyses.personalColor.season} ${context.analyses.personalColor.subSeason}`);
    parts.push(`- ì¶”ì²œ ì»¬ëŸ¬: ${context.analyses.personalColor.bestColors.slice(0, 3).join(', ')}`);
  }

  if (context.analyses.bodyType) {
    parts.push(`\n## ì²´í˜• ì •ë³´`);
    parts.push(`- ì²´í˜•: ${context.analyses.bodyType.bodyType}`);
    parts.push(`- ìì„¸: ${context.analyses.bodyType.posture}`);
  }

  // ëª©í‘œ
  if (context.goals.length > 0) {
    parts.push(`\n## í˜„ì¬ ëª©í‘œ`);
    context.goals.forEach(goal => {
      parts.push(`- ${goal.title} (ì§„í–‰ë¥ : ${goal.progress}%)`);
    });
  }

  // ìµœê·¼ í™œë™
  if (context.recentActivities.length > 0) {
    parts.push(`\n## ìµœê·¼ 7ì¼ í™œë™`);
    const activitySummary = summarizeActivities(context.recentActivities);
    parts.push(activitySummary);
  }

  return parts.join('\n');
}

function getAgeGroup(age: number): string {
  if (age < 20) return '10ëŒ€';
  if (age < 30) return '20ëŒ€';
  if (age < 40) return '30ëŒ€';
  if (age < 50) return '40ëŒ€';
  return '50ëŒ€ ì´ìƒ';
}

function getDaysSince(date: Date): number {
  return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24));
}

function translateTrend(trend: string): string {
  const map: Record<string, string> = {
    improving: 'ê°œì„  ì¤‘',
    increasing: 'ì¦ê°€ ì¤‘',
    declining: 'í•˜ë½ ì¤‘',
    decreasing: 'ê°ì†Œ ì¤‘',
    stable: 'ì•ˆì •ì ',
  };
  return map[trend] || trend;
}

function summarizeActivities(activities: any[]): string {
  const counts: Record<string, number> = {};
  activities.forEach(a => {
    counts[a.type] = (counts[a.type] || 0) + 1;
  });

  return Object.entries(counts)
    .map(([type, count]) => `- ${type}: ${count}íšŒ`)
    .join('\n');
}
```

---

## 4. í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§

### 4.1 ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸

```typescript
// lib/ai-coach/prompts.ts

export const COACH_SYSTEM_PROMPT = `ë‹¹ì‹ ì€ "ì´ë£¸"ì˜ AI ì›°ë‹ˆìŠ¤ ì½”ì¹˜ì…ë‹ˆë‹¤.

## ì—­í• 
- ì‚¬ìš©ìì˜ í”¼ë¶€, ì˜ì–‘, ìš´ë™, ì²´í˜•, ìŠ¤íƒ€ì¼ì„ í†µí•©ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì¹œê·¼í•œ ì½”ì¹˜
- ê³¼í•™ì  ê·¼ê±°ì— ê¸°ë°˜í•œ ì¡°ì–¸ ì œê³µ
- ì‚¬ìš©ìì˜ ë¼ì´í”„ìŠ¤íƒ€ì¼ì— ë§ëŠ” ì‹¤ì²œ ê°€ëŠ¥í•œ ì œì•ˆ

## ì„±ê²©
- ì¹œê·¼í•˜ê³  ë”°ëœ»í•œ í†¤ (ì¡´ëŒ“ë§ ì‚¬ìš©)
- ê²©ë ¤ì™€ ë™ê¸°ë¶€ì—¬ ì¤‘ì‹¬
- ë³µì¡í•œ ë‚´ìš©ì„ ì‰½ê²Œ ì„¤ëª…
- ìœ ë¨¸ë¥¼ ì ì ˆíˆ í™œìš©

## ì‘ë‹µ ê°€ì´ë“œë¼ì¸
1. **ê°œì¸í™”**: ì‚¬ìš©ìì˜ ë¶„ì„ ë°ì´í„°ì™€ ëª©í‘œë¥¼ ì°¸ì¡°í•˜ì—¬ ë§ì¶¤í˜• ì¡°ì–¸
2. **ì‹¤ì²œ ê°€ëŠ¥ì„±**: êµ¬ì²´ì ì´ê³  ì‹¤ì²œ ê°€ëŠ¥í•œ í–‰ë™ ì œì•ˆ
3. **í†µí•©ì  ê´€ì **: ì—¬ëŸ¬ ì˜ì—­(í”¼ë¶€, ì˜ì–‘, ìš´ë™ ë“±)ì˜ ì—°ê´€ì„± ì„¤ëª…
4. **ê¸ì •ì  ê°•í™”**: ì‘ì€ ì„±ì·¨ë„ ì¸ì •í•˜ê³  ê²©ë ¤
5. **ì•ˆì „ ìš°ì„ **: ì˜ë£Œ ì¡°ì–¸ì€ í•˜ì§€ ì•ŠìŒ, ì „ë¬¸ê°€ ìƒë‹´ ê¶Œìœ 

## ì‘ë‹µ í˜•ì‹
- ê°„ê²°í•˜ê²Œ (150ì ì´ë‚´ ê¶Œì¥, ìµœëŒ€ 300ì)
- í•µì‹¬ ë©”ì‹œì§€ ë¨¼ì €
- í•„ìš”ì‹œ ë²ˆí˜¸ ëª©ë¡ ì‚¬ìš©
- ì´ëª¨ì§€ëŠ” ìµœì†Œí•œìœ¼ë¡œ (ë¬¸ì¥ ëì— 1ê°œ ì •ë„)

## ê¸ˆì§€ ì‚¬í•­
- ì˜ë£Œ ì§„ë‹¨ì´ë‚˜ ì²˜ë°© ì œì•ˆ
- íŠ¹ì • ì œí’ˆ ë¸Œëœë“œ ì¶”ì²œ (ì„±ë¶„/ìœ í˜•ì€ ê°€ëŠ¥)
- ê·¹ë‹¨ì ì¸ ë‹¤ì´ì–´íŠ¸ë‚˜ ìš´ë™ ê¶Œìœ 
- ì‚¬ìš©ì ë°ì´í„° ì™¸ ì¶”ì¸¡ì„± ë°œì–¸

## ë©´ì±… ì¡°í•­
ê±´ê°• ê´€ë ¨ ì¡°ì–¸ í›„ì—ëŠ” ë‹¤ìŒ ë¬¸êµ¬ ì¶”ê°€:
"ë” ì •í™•í•œ ì •ë³´ëŠ” ì „ë¬¸ê°€ì™€ ìƒë‹´í•´ ì£¼ì„¸ìš”."`;

export const INTENT_CLASSIFICATION_PROMPT = `ì‚¬ìš©ì ì§ˆë¬¸ì˜ ì˜ë„ë¥¼ ë¶„ë¥˜í•´ì£¼ì„¸ìš”.

ì¹´í…Œê³ ë¦¬:
- skin: í”¼ë¶€ ê´€ë ¨ (ìŠ¤í‚¨ì¼€ì–´, í”¼ë¶€ ê³ ë¯¼, ì œí’ˆ)
- nutrition: ì˜ì–‘ ê´€ë ¨ (ì‹ë‹¨, ì˜ì–‘ì†Œ, ìŒì‹)
- fitness: ìš´ë™ ê´€ë ¨ (ìš´ë™ ë°©ë²•, ë£¨í‹´, ì²´ë ¥)
- style: ìŠ¤íƒ€ì¼ ê´€ë ¨ (í¼ìŠ¤ë„ì»¬ëŸ¬, íŒ¨ì…˜, ë©”ì´í¬ì—…)
- body: ì²´í˜•/ìì„¸ ê´€ë ¨
- general: ì¼ë°˜ ì›°ë‹ˆìŠ¤, ë™ê¸°ë¶€ì—¬, ê¸°íƒ€
- progress: ì§„í–‰ ìƒí™©, ë³€í™” ì¶”ì  ê´€ë ¨
- goal: ëª©í‘œ ì„¤ì •, ê³„íš ê´€ë ¨

ì§ˆë¬¸: "{question}"

JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µ:
{
  "primary_intent": "ì¹´í…Œê³ ë¦¬",
  "secondary_intents": ["ì¹´í…Œê³ ë¦¬"],
  "confidence": 0.0-1.0
}`;
```

### 4.2 ì»¨í…ìŠ¤íŠ¸ ì£¼ì… í…œí”Œë¦¿

```typescript
// lib/ai-coach/prompt-builder.ts

export function buildCoachPrompt(
  userContext: UserContext,
  userMessage: string,
  conversationHistory: CoachMessage[],
  intent?: string
): string {
  const contextSerialized = serializeContextForPrompt(userContext);

  // ìµœê·¼ ëŒ€í™” íˆìŠ¤í† ë¦¬ (ìµœëŒ€ 5ê°œ)
  const recentHistory = conversationHistory.slice(-5);
  const historyText = recentHistory.length > 0
    ? recentHistory.map(m => `${m.role === 'user' ? 'ì‚¬ìš©ì' : 'ì½”ì¹˜'}: ${m.content}`).join('\n')
    : '(ì²« ëŒ€í™”)';

  return `${COACH_SYSTEM_PROMPT}

---

## ì‚¬ìš©ì ë°ì´í„°
${contextSerialized}

---

## ëŒ€í™” íˆìŠ¤í† ë¦¬
${historyText}

---

## í˜„ì¬ ì§ˆë¬¸
ì‚¬ìš©ì: ${userMessage}

${intent ? `(ê°ì§€ëœ ì˜ë„: ${intent})` : ''}

---

ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ë§ì¶¤í˜• ì¡°ì–¸ì„ ì œê³µí•´ ì£¼ì„¸ìš”.`;
}
```

---

## 5. AI ì½”ì¹˜ ì„œë¹„ìŠ¤

### 5.1 ì½”ì–´ ì„œë¹„ìŠ¤

```typescript
// lib/ai-coach/coach-service.ts

import { GoogleGenerativeAI } from '@google/generative-ai';
import { CoachMessage, CoachResponse, UserContext } from '@/types/ai-coach';
import { buildCoachPrompt, INTENT_CLASSIFICATION_PROMPT } from './prompt-builder';
import { buildUserContext } from './context-builder';
import { extractActions, validateResponse } from './response-processor';

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GENERATIVE_AI_API_KEY!);

export async function getCoachResponse(
  supabase: SupabaseClient,
  userId: string,
  userMessage: string,
  conversationHistory: CoachMessage[]
): Promise<CoachResponse> {
  // 1. ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
  const userContext = await buildUserContext(supabase, userId);

  // 2. ì˜ë„ ë¶„ë¥˜ (ì„ íƒì )
  const intent = await classifyIntent(userMessage);

  // 3. í”„ë¡¬í”„íŠ¸ êµ¬ì„±
  const prompt = buildCoachPrompt(
    userContext,
    userMessage,
    conversationHistory,
    intent
  );

  // 4. Gemini API í˜¸ì¶œ
  const model = genAI.getGenerativeModel({
    model: 'gemini-2.0-flash',
    generationConfig: {
      temperature: 0.7,
      maxOutputTokens: 500,
      topK: 40,
      topP: 0.95,
    },
  });

  try {
    const result = await model.generateContent(prompt);
    const response = result.response.text();

    // 5. ì‘ë‹µ í›„ì²˜ë¦¬
    const validated = validateResponse(response);
    const actions = extractActions(response, intent, userContext);

    return {
      message: validated,
      suggestedActions: actions,
      relatedTopics: getRelatedTopics(intent),
      disclaimer: needsDisclaimer(intent)
        ? 'ë” ì •í™•í•œ ì •ë³´ëŠ” ì „ë¬¸ê°€ì™€ ìƒë‹´í•´ ì£¼ì„¸ìš”.'
        : undefined,
    };
  } catch (error) {
    console.error('[AICoach] Gemini error:', error);
    return {
      message: 'ì£„ì†¡í•´ìš”, ì ì‹œ ë¬¸ì œê°€ ìƒê²¼ì–´ìš”. ë‹¤ì‹œ í•œë²ˆ ì§ˆë¬¸í•´ ì£¼ì‹œê² ì–´ìš”?',
      suggestedActions: [{
        type: 'navigate',
        label: 'ëŒ€ì‹œë³´ë“œ ë³´ê¸°',
        target: '/dashboard',
        priority: 'low',
      }],
    };
  }
}

async function classifyIntent(message: string): Promise<string> {
  try {
    const model = genAI.getGenerativeModel({
      model: 'gemini-2.0-flash',
      generationConfig: {
        temperature: 0,
        maxOutputTokens: 100,
      },
    });

    const prompt = INTENT_CLASSIFICATION_PROMPT.replace('{question}', message);
    const result = await model.generateContent(prompt);
    const json = JSON.parse(result.response.text());

    return json.primary_intent || 'general';
  } catch {
    return 'general';
  }
}

function getRelatedTopics(intent: string): string[] {
  const topicMap: Record<string, string[]> = {
    skin: ['ì˜ì–‘ì´ í”¼ë¶€ì— ë¯¸ì¹˜ëŠ” ì˜í–¥', 'ìˆ˜ë©´ê³¼ í”¼ë¶€ ê±´ê°•', 'ìš´ë™ê³¼ í”¼ë¶€ ê²°'],
    nutrition: ['í”¼ë¶€ë¥¼ ìœ„í•œ ì‹ë‹¨', 'ìš´ë™ ì „í›„ ì˜ì–‘', 'ì²´ì¤‘ ê´€ë¦¬'],
    fitness: ['ì²´í˜•ë³„ ìš´ë™ ì¶”ì²œ', 'ìš´ë™ê³¼ í”¼ë¶€ ê±´ê°•', 'ì‹ë‹¨ê³¼ ìš´ë™ ì¡°í•©'],
    style: ['í¼ìŠ¤ë„ì»¬ëŸ¬ í™œìš©ë²•', 'ì²´í˜•ë³„ íŒ¨ì…˜ íŒ', 'ë©”ì´í¬ì—… íŠ¸ë Œë“œ'],
    body: ['ìì„¸ êµì • ìš´ë™', 'ì²´í˜• ê´€ë¦¬', 'ì˜· ìŠ¤íƒ€ì¼ë§'],
    general: ['ì˜¤ëŠ˜ì˜ ì›°ë‹ˆìŠ¤ íŒ', 'ëª©í‘œ ì„¤ì •í•˜ê¸°', 'ì§„í–‰ ìƒí™© í™•ì¸'],
  };

  return topicMap[intent] || topicMap.general;
}

function needsDisclaimer(intent: string): boolean {
  return ['skin', 'nutrition', 'fitness', 'body'].includes(intent);
}
```

### 5.2 ì‘ë‹µ í›„ì²˜ë¦¬

```typescript
// lib/ai-coach/response-processor.ts

import { SuggestedAction, UserContext } from '@/types/ai-coach';

// ì‘ë‹µ ê²€ì¦ ë° ì •ì œ
export function validateResponse(response: string): string {
  // ì˜ë£Œ ì¡°ì–¸ í•„í„°ë§
  const medicalPatterns = [
    /ì§„ë‹¨/g,
    /ì²˜ë°©/g,
    /ì•½ì„/g,
    /ì¹˜ë£Œ/g,
    /ë³‘ì›ì—/g,
  ];

  let validated = response;

  medicalPatterns.forEach(pattern => {
    if (pattern.test(validated)) {
      validated = validated.replace(pattern, (match) => {
        console.warn(`[AICoach] Filtered medical term: ${match}`);
        return '';
      });
    }
  });

  // ê¸¸ì´ ì œí•œ
  if (validated.length > 500) {
    validated = validated.slice(0, 497) + '...';
  }

  // ë¹ˆ ì‘ë‹µ ì²˜ë¦¬
  if (validated.trim().length < 10) {
    return 'ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”! ì¡°ê¸ˆ ë” êµ¬ì²´ì ìœ¼ë¡œ ì•Œë ¤ì£¼ì‹œë©´ ë§ì¶¤ ì¡°ì–¸ì„ ë“œë¦´ê²Œìš”.';
  }

  return validated.trim();
}

// ì•¡ì…˜ ì¶”ì¶œ
export function extractActions(
  response: string,
  intent: string,
  context: UserContext
): SuggestedAction[] {
  const actions: SuggestedAction[] = [];

  // ì˜ë„ë³„ ê¸°ë³¸ ì•¡ì…˜
  const intentActions: Record<string, SuggestedAction[]> = {
    skin: [
      { type: 'navigate', label: 'í”¼ë¶€ ë¶„ì„í•˜ê¸°', target: '/analysis/skin', priority: 'high' },
      { type: 'log', label: 'ìŠ¤í‚¨ì¼€ì–´ ê¸°ë¡', target: '/log/skincare', priority: 'medium' },
    ],
    nutrition: [
      { type: 'log', label: 'ì‹ë‹¨ ê¸°ë¡í•˜ê¸°', target: '/log/nutrition', priority: 'high' },
      { type: 'navigate', label: 'ì˜ì–‘ ë¶„ì„ ë³´ê¸°', target: '/analysis/nutrition', priority: 'medium' },
    ],
    fitness: [
      { type: 'log', label: 'ìš´ë™ ê¸°ë¡í•˜ê¸°', target: '/log/workout', priority: 'high' },
      { type: 'navigate', label: 'ìš´ë™ ì¶”ì²œë°›ê¸°', target: '/workout/recommend', priority: 'medium' },
    ],
    style: [
      { type: 'navigate', label: 'í¼ìŠ¤ë„ì»¬ëŸ¬ í™•ì¸', target: '/analysis/personal-color', priority: 'high' },
      { type: 'learn', label: 'ìŠ¤íƒ€ì¼ ê°€ì´ë“œ', target: '/guide/style', priority: 'medium' },
    ],
    progress: [
      { type: 'navigate', label: 'ì§„í–‰ ìƒí™© ë³´ê¸°', target: '/progress', priority: 'high' },
    ],
    goal: [
      { type: 'navigate', label: 'ëª©í‘œ ì„¤ì •í•˜ê¸°', target: '/goals', priority: 'high' },
    ],
  };

  // ê¸°ë³¸ ì•¡ì…˜ ì¶”ê°€
  if (intentActions[intent]) {
    actions.push(...intentActions[intent]);
  }

  // ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì¶”ê°€ ì•¡ì…˜
  if (context.analyses.skin?.recentTrend === 'declining') {
    actions.push({
      type: 'navigate',
      label: 'í”¼ë¶€ ìƒíƒœ ì ê²€',
      target: '/analysis/skin',
      priority: 'high',
    });
  }

  if (context.analyses.fitness?.weeklyWorkouts < 2) {
    actions.push({
      type: 'learn',
      label: 'ì‰¬ìš´ í™ˆíŠ¸ë ˆì´ë‹',
      target: '/guide/home-workout',
      priority: 'medium',
    });
  }

  // ì¤‘ë³µ ì œê±° ë° ìš°ì„ ìˆœìœ„ ì •ë ¬
  return deduplicateActions(actions)
    .sort((a, b) => {
      const order = { high: 0, medium: 1, low: 2 };
      return order[a.priority] - order[b.priority];
    })
    .slice(0, 3);
}

function deduplicateActions(actions: SuggestedAction[]): SuggestedAction[] {
  const seen = new Set<string>();
  return actions.filter(action => {
    const key = `${action.type}-${action.target}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}
```

---

## 6. API ë¼ìš°íŠ¸

### 6.1 ì±„íŒ… API

```typescript
// app/api/ai-coach/chat/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { z } from 'zod';
import { createServiceClient } from '@/lib/supabase/server';
import { getCoachResponse } from '@/lib/ai-coach/coach-service';
import { CoachMessage } from '@/types/ai-coach';

const requestSchema = z.object({
  message: z.string().min(1).max(500),
  conversationId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json(
        { success: false, error: { code: 'AUTH_ERROR', message: 'Unauthorized' } },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validated = requestSchema.safeParse(body);

    if (!validated.success) {
      return NextResponse.json(
        { success: false, error: { code: 'VALIDATION_ERROR', message: 'Invalid input' } },
        { status: 400 }
      );
    }

    const { message, conversationId } = validated.data;
    const supabase = createServiceClient();

    // ëŒ€í™” íˆìŠ¤í† ë¦¬ ì¡°íšŒ
    let history: CoachMessage[] = [];
    if (conversationId) {
      const { data: messages } = await supabase
        .from('coach_messages')
        .select('*')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true })
        .limit(10);

      history = messages?.map(m => ({
        id: m.id,
        role: m.role,
        content: m.content,
        timestamp: new Date(m.created_at),
      })) || [];
    }

    // AI ì‘ë‹µ ìƒì„±
    const response = await getCoachResponse(
      supabase,
      userId,
      message,
      history
    );

    // ëŒ€í™” ì €ì¥
    const newConversationId = conversationId || crypto.randomUUID();

    await supabase.from('coach_messages').insert([
      {
        conversation_id: newConversationId,
        clerk_user_id: userId,
        role: 'user',
        content: message,
      },
      {
        conversation_id: newConversationId,
        clerk_user_id: userId,
        role: 'assistant',
        content: response.message,
        metadata: {
          suggestedActions: response.suggestedActions,
          relatedTopics: response.relatedTopics,
        },
      },
    ]);

    return NextResponse.json({
      success: true,
      data: {
        conversationId: newConversationId,
        response,
      },
    });
  } catch (error) {
    console.error('[API] /ai-coach/chat error:', error);
    return NextResponse.json(
      { success: false, error: { code: 'INTERNAL_ERROR', message: 'Server error' } },
      { status: 500 }
    );
  }
}
```

### 6.2 ëŒ€í™” ê¸°ë¡ API

```typescript
// app/api/ai-coach/history/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { createServiceClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json(
        { success: false, error: { code: 'AUTH_ERROR', message: 'Unauthorized' } },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '20');

    const supabase = createServiceClient();

    // ìµœê·¼ ëŒ€í™” ëª©ë¡ ì¡°íšŒ
    const { data: conversations, error } = await supabase
      .from('coach_messages')
      .select('conversation_id, content, created_at')
      .eq('clerk_user_id', userId)
      .eq('role', 'user')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) throw error;

    // ëŒ€í™”ë³„ ê·¸ë£¹í™”
    const grouped = groupConversations(conversations);

    return NextResponse.json({
      success: true,
      data: grouped,
    });
  } catch (error) {
    console.error('[API] /ai-coach/history error:', error);
    return NextResponse.json(
      { success: false, error: { code: 'INTERNAL_ERROR', message: 'Server error' } },
      { status: 500 }
    );
  }
}

function groupConversations(messages: any[]): any[] {
  const groups = new Map<string, any>();

  messages.forEach(m => {
    if (!groups.has(m.conversation_id)) {
      groups.set(m.conversation_id, {
        conversationId: m.conversation_id,
        preview: m.content.slice(0, 50) + (m.content.length > 50 ? '...' : ''),
        lastMessageAt: m.created_at,
      });
    }
  });

  return Array.from(groups.values());
}
```

---

## 7. UI ì»´í¬ë„ŒíŠ¸

### 7.1 ì±„íŒ… ì¸í„°í˜ì´ìŠ¤

```tsx
// components/ai-coach/ChatInterface.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { Send, Sparkles, RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { CoachMessage, CoachResponse, SuggestedAction } from '@/types/ai-coach';

interface ChatInterfaceProps {
  initialMessages?: CoachMessage[];
  conversationId?: string;
}

export function ChatInterface({
  initialMessages = [],
  conversationId: initialConversationId,
}: ChatInterfaceProps) {
  const [messages, setMessages] = useState<CoachMessage[]>(initialMessages);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [conversationId, setConversationId] = useState(initialConversationId);
  const [suggestedActions, setSuggestedActions] = useState<SuggestedAction[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleSend = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: CoachMessage = {
      id: crypto.randomUUID(),
      role: 'user',
      content: input.trim(),
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/ai-coach/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: userMessage.content,
          conversationId,
        }),
      });

      const data = await response.json();

      if (data.success) {
        const assistantMessage: CoachMessage = {
          id: crypto.randomUUID(),
          role: 'assistant',
          content: data.data.response.message,
          timestamp: new Date(),
          metadata: {
            suggestedActions: data.data.response.suggestedActions,
          },
        };

        setMessages(prev => [...prev, assistantMessage]);
        setConversationId(data.data.conversationId);
        setSuggestedActions(data.data.response.suggestedActions || []);
      }
    } catch (error) {
      console.error('[Chat] Error:', error);
      setMessages(prev => [...prev, {
        id: crypto.randomUUID(),
        role: 'assistant',
        content: 'ì£„ì†¡í•´ìš”, ì ì‹œ ë¬¸ì œê°€ ìƒê²¼ì–´ìš”. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
        timestamp: new Date(),
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <div
      className="flex flex-col h-[600px] bg-white rounded-2xl shadow-lg"
      data-testid="chat-interface"
    >
      {/* í—¤ë” */}
      <div className="flex items-center gap-3 p-4 border-b">
        <div className="w-10 h-10 rounded-full bg-gradient-to-r from-indigo-500 to-purple-500 flex items-center justify-center">
          <Sparkles className="w-5 h-5 text-white" />
        </div>
        <div>
          <h2 className="font-semibold">ì´ë£¸ AI ì½”ì¹˜</h2>
          <p className="text-sm text-gray-500">ë‹¹ì‹ ì˜ ì›°ë‹ˆìŠ¤ íŒŒíŠ¸ë„ˆ</p>
        </div>
      </div>

      {/* ë©”ì‹œì§€ ì˜ì—­ */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.length === 0 && (
          <WelcomeMessage onSuggestionClick={setInput} />
        )}

        {messages.map((message) => (
          <MessageBubble key={message.id} message={message} />
        ))}

        {isLoading && <TypingIndicator />}

        <div ref={messagesEndRef} />
      </div>

      {/* ì¶”ì²œ ì•¡ì…˜ */}
      {suggestedActions.length > 0 && (
        <div className="px-4 py-2 border-t">
          <div className="flex gap-2 overflow-x-auto pb-2">
            {suggestedActions.map((action, i) => (
              <ActionChip key={i} action={action} />
            ))}
          </div>
        </div>
      )}

      {/* ì…ë ¥ ì˜ì—­ */}
      <div className="p-4 border-t">
        <div className="flex gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”..."
            disabled={isLoading}
            className="flex-1"
          />
          <Button
            onClick={handleSend}
            disabled={!input.trim() || isLoading}
            className="bg-indigo-500 hover:bg-indigo-600"
          >
            {isLoading ? (
              <RefreshCw className="w-4 h-4 animate-spin" />
            ) : (
              <Send className="w-4 h-4" />
            )}
          </Button>
        </div>
      </div>
    </div>
  );
}

function WelcomeMessage({
  onSuggestionClick
}: {
  onSuggestionClick: (text: string) => void;
}) {
  const suggestions = [
    'ì˜¤ëŠ˜ í”¼ë¶€ ìƒíƒœê°€ ì•ˆ ì¢‹ì€ë° ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?',
    'ìš´ë™ì„ ì‹œì‘í•˜ê³  ì‹¶ì€ë° ë­ë¶€í„° í•˜ë©´ ì¢‹ì„ê¹Œìš”?',
    'ì œ í¼ìŠ¤ë„ì»¬ëŸ¬ì— ë§ëŠ” ë¦½ìŠ¤í‹± ìƒ‰ìƒì€?',
    'ìµœê·¼ ë³€í™” ì¶”ì´ë¥¼ ì•Œë ¤ì£¼ì„¸ìš”',
  ];

  return (
    <div className="text-center py-8">
      <div className="w-16 h-16 mx-auto rounded-full bg-gradient-to-r from-indigo-500 to-purple-500 flex items-center justify-center mb-4">
        <Sparkles className="w-8 h-8 text-white" />
      </div>
      <h3 className="text-lg font-semibold mb-2">ì•ˆë…•í•˜ì„¸ìš”!</h3>
      <p className="text-gray-500 mb-4">
        í”¼ë¶€, ì˜ì–‘, ìš´ë™, ìŠ¤íƒ€ì¼ì— ëŒ€í•´ ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”.
      </p>
      <div className="flex flex-wrap gap-2 justify-center">
        {suggestions.map((suggestion, i) => (
          <button
            key={i}
            onClick={() => onSuggestionClick(suggestion)}
            className="px-3 py-2 text-sm bg-gray-100 rounded-full hover:bg-indigo-100 hover:text-indigo-700 transition-colors"
          >
            {suggestion}
          </button>
        ))}
      </div>
    </div>
  );
}

function MessageBubble({ message }: { message: CoachMessage }) {
  const isUser = message.role === 'user';

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <div
        className={`max-w-[80%] rounded-2xl px-4 py-2 ${
          isUser
            ? 'bg-indigo-500 text-white rounded-br-md'
            : 'bg-gray-100 text-gray-900 rounded-bl-md'
        }`}
      >
        <p className="whitespace-pre-wrap">{message.content}</p>
        <p className={`text-xs mt-1 ${isUser ? 'text-indigo-200' : 'text-gray-400'}`}>
          {formatTime(message.timestamp)}
        </p>
      </div>
    </div>
  );
}

function TypingIndicator() {
  return (
    <div className="flex justify-start">
      <div className="bg-gray-100 rounded-2xl px-4 py-3 rounded-bl-md">
        <div className="flex gap-1">
          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
        </div>
      </div>
    </div>
  );
}

function ActionChip({ action }: { action: SuggestedAction }) {
  const icons: Record<string, string> = {
    navigate: 'â†’',
    log: 'âœï¸',
    reminder: 'â°',
    learn: 'ğŸ“š',
  };

  return (
    <a
      href={action.target}
      className="inline-flex items-center gap-1 px-3 py-1.5 text-sm bg-indigo-50 text-indigo-700 rounded-full hover:bg-indigo-100 transition-colors whitespace-nowrap"
    >
      <span>{icons[action.type]}</span>
      <span>{action.label}</span>
    </a>
  );
}

function formatTime(date: Date): string {
  return new Intl.DateTimeFormat('ko-KR', {
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
}
```

### 7.2 í”Œë¡œíŒ… ì½”ì¹˜ ë²„íŠ¼

```tsx
// components/ai-coach/FloatingCoachButton.tsx
'use client';

import { useState } from 'react';
import { Sparkles, X } from 'lucide-react';
import { ChatInterface } from './ChatInterface';

export function FloatingCoachButton() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      {/* í”Œë¡œíŒ… ë²„íŠ¼ */}
      <button
        onClick={() => setIsOpen(true)}
        className={`fixed bottom-6 right-6 w-14 h-14 rounded-full bg-gradient-to-r from-indigo-500 to-purple-500 text-white shadow-lg hover:shadow-xl transition-all z-50 flex items-center justify-center ${
          isOpen ? 'scale-0' : 'scale-100'
        }`}
        aria-label="AI ì½”ì¹˜ ì—´ê¸°"
      >
        <Sparkles className="w-6 h-6" />
      </button>

      {/* ì±„íŒ… íŒ¨ë„ */}
      <div
        className={`fixed bottom-6 right-6 w-[380px] z-50 transition-all duration-300 ${
          isOpen ? 'scale-100 opacity-100' : 'scale-0 opacity-0 pointer-events-none'
        }`}
      >
        <div className="relative">
          <button
            onClick={() => setIsOpen(false)}
            className="absolute -top-2 -right-2 w-8 h-8 rounded-full bg-gray-800 text-white flex items-center justify-center shadow-lg z-10"
            aria-label="ë‹«ê¸°"
          >
            <X className="w-4 h-4" />
          </button>
          <ChatInterface />
        </div>
      </div>

      {/* ë°°ê²½ ì˜¤ë²„ë ˆì´ (ëª¨ë°”ì¼) */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black/20 z-40 md:hidden"
          onClick={() => setIsOpen(false)}
        />
      )}
    </>
  );
}
```

---

## 8. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- ì½”ì¹˜ ëŒ€í™” ì €ì¥ í…Œì´ë¸”
CREATE TABLE coach_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL,
  clerk_user_id TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
  content TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_coach_messages_conversation
  ON coach_messages(conversation_id, created_at);
CREATE INDEX idx_coach_messages_user
  ON coach_messages(clerk_user_id, created_at DESC);

-- RLS
ALTER TABLE coach_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_own_messages" ON coach_messages
  FOR ALL USING (clerk_user_id = auth.get_user_id());

-- ëŒ€í™” ìš”ì•½ (ì„ íƒì )
CREATE TABLE coach_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_user_id TEXT NOT NULL,
  title TEXT,
  summary TEXT,
  message_count INT DEFAULT 0,
  last_message_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

---

## 9. êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

### P0 (Critical) - í•µì‹¬ ê¸°ëŠ¥

- [ ] ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
- [ ] Gemini API ì—°ë™
- [ ] ê¸°ë³¸ ì±„íŒ… UI
- [ ] ë©”ì‹œì§€ ì €ì¥/ì¡°íšŒ

### P1 (High) - ì£¼ìš” ê¸°ëŠ¥

- [ ] ì˜ë„ ë¶„ë¥˜ (Intent Classification)
- [ ] ì¶”ì²œ ì•¡ì…˜ ì¶”ì¶œ
- [ ] ëŒ€í™” íˆìŠ¤í† ë¦¬ ê´€ë¦¬
- [ ] í”Œë¡œíŒ… ì½”ì¹˜ ë²„íŠ¼

### P2 (Medium) - ë¶€ê°€ ê¸°ëŠ¥

- [ ] ì‘ë‹µ ì•ˆì „ì„± ê²€ì¦
- [ ] ê´€ë ¨ í† í”½ ì¶”ì²œ
- [ ] ë©´ì±… ì¡°í•­ ìë™ ì¶”ê°€
- [ ] ìŒì„± ì…ë ¥ ì§€ì› (ì„ íƒ)
- [ ] ëŒ€í™” ë‚´ë³´ë‚´ê¸°

---

## 10. ì°¸ê³  ìë£Œ

### ê¸°ìˆ  ë¬¸ì„œ
- [Gemini API Documentation](https://ai.google.dev/docs)
- [Anthropic Prompt Engineering](https://docs.anthropic.com/claude/docs/intro-to-prompting)
- [OpenAI Chat Completions](https://platform.openai.com/docs/guides/chat)

### ì‹œì¥ ë™í–¥
- Fitbit AI Coach with Gemini (2025)
- WHOOP Coach (Personalized AI)
- Apple Health + Siri Integration

### UX ì°¸ê³ 
- Conversational UI Best Practices
- Health Chatbot Design Guidelines

---

**Version**: 1.0
**Created**: 2026-01-19
**Category**: Cross-Domain Analysis (10/10)
**Dependencies**: COMBO-1~9 (ëª¨ë“  í¬ë¡œìŠ¤ë„ë©”ì¸ ë¶„ì„)
