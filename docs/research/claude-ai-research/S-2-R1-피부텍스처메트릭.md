# 피부 텍스처 이미지 분석 알고리즘 가이드

피부 텍스처 분석을 위한 핵심 알고리즘과 측정 방법론을 종합한 결과, **모공 감지에는 OpenCV SimpleBlobDetector와 U-Net 기반 딥러닝이 가장 효과적**이며, **표면 거칠기 측정에는 Ra/Rq/Rz 파라미터와 GLCM/LBP 텍스처 분석의 조합**이 표준으로 사용된다. 피부 수분도와 roughness의 상관관계는 **R² = 0.524 수준**으로 중간 정도이며, TEWL(경피수분손실)이 더 강력한 예측 인자다. T존과 U존은 피지 분비량에서 **2-3배 이상 차이**를 보이며, 아시아인(특히 한국인/중국인)은 다른 인종 대비 **가장 작은 모공 크기**를 나타낸다.

---

## 모공 가시성 수치화 방법

### 이미지 전처리 파이프라인

모공 감지 전 **CLAHE(Contrast Limited Adaptive Histogram Equalization)** 적용이 필수적이다. CLAHE는 이미지를 타일로 분할하여 국소적 히스토그램 평활화를 수행하며, clipLimit 파라미터로 노이즈 증폭을 방지한다. 권장 설정은 **clipLimit=2.0, tileGridSize=(8,8)** 이다.

전처리 순서는 그레이스케일 변환 → CLAHE 적용 → 가우시안 블러(노이즈 제거) → 모공 감지 순으로 진행된다. HSV 색공간의 V채널 활용이나 Top-hat 변환도 조명 불균일 보정에 효과적이다.

### SimpleBlobDetector 기반 모공 감지

OpenCV의 **SimpleBlobDetector**는 가장 널리 사용되는 고전적 모공 감지 알고리즘이다. 핵심 파라미터 설정:

- **minArea/maxArea**: 50-700 pixels² (모공 크기 필터링)
- **minCircularity**: 0.6-0.8 (원형도, 1.0=완벽한 원)
- **blobColor**: 0 (어두운 영역 감지)
- **minConvexity**: 0.5 (볼록성)
- **minInertiaRatio**: 0.01 (관성비)

알고리즘은 다중 임계값으로 이진화 → 연결 성분 그룹화 → 근접 중심 병합 → 형태 필터링 순으로 동작한다.

### 딥러닝 기반 모공 세분화

**U-Net 아키텍처**가 모공 세분화에 가장 많이 사용된다. Encoder-decoder 구조에 skip connection을 적용하며, 입력 크기는 보통 **768×640 픽셀**이다. 최신 연구에서 Attention 메커니즘을 추가한 U-Net은 모공 IoU **0.4032**를 달성했다.

| 모델 | 모공 IoU | 파라미터 수 |
|------|----------|------------|
| Vanilla U-Net | 0.3601 | 17.3M |
| U-Net++ | 0.3669 | - |
| U-Net + Attention | **0.4032** | 5.2M |

모공 Ground Truth 생성을 위한 Laplacian 피라미드 방식:
```
T(x,y) = t · 1_{|t| > Th}
where t = -L₀(x,y) + Expand(L₁(x,y))
```

### 모공 측정 메트릭 공식

**모공 면적**: `Area = Σ pixels within contour` (pixels² 또는 mm² 변환)

**등가 직경**: `Equivalent Diameter = √(4 × Area / π)`

**원형도 (Circularity)**: `C = 4π × Area / Perimeter²` (1.0=완벽한 원)

**신장도 (Elongation)**: `E = Major_Axis / Minor_Axis` (노화 지표)

**모공 밀도**: `Density = Number of pores / ROI Area` (pores/cm²)

**가시성 지수**: `PVI = (Σ Individual_Pore_Area × Contrast_Factor) / Total_ROI_Area × 100`

### 모공 점수화 시스템

임상 시각 평가 척도(0-6점): **0점**=거의 보이지 않음, **3-4점**=보통/복합성, **5-6점**=명확히 보이는 큰 모공(지성)

AI 기반 점수(0-1000점): 100만 중국인 대상 연구에서 검증됨. 볼 평균 286점, 코 평균 194점. 분류 정확도 **95.7%**, 재현율 **97.6%**.

---

## Roughness 측정 알고리즘

### 표면 거칠기 표준 파라미터 (ISO 4287)

**Ra (산술 평균 거칠기)**는 평가 길이에서 평균선으로부터의 절대 높이 편차의 산술 평균이다:

$$Ra = \frac{1}{L} \int_0^L |Z(x)| dx$$

이산화: $Ra = \frac{1}{n} \sum_{i=1}^{n} |Z_i|$

정상 피부 Ra 값: **20-60 μm**

**Rq (RMS 거칠기)**는 프로파일 높이 편차의 제곱평균제곱근이다:

$$Rq = \sqrt{\frac{1}{L} \int_0^L Z^2(x) dx}$$

가우시안 분포에서 **Rq ≈ 1.11 × Ra**

**Rz (최대 높이)**는 5개 최고봉과 5개 최저곡의 평균이다:

$$Rz = \frac{1}{5} \sum_{i=1}^{5} (Rp_i + Rv_i)$$

| 파라미터 | 공식 | 피부 정상값 |
|---------|------|-----------|
| Ra | 절대편차 평균 | 13-35 μm |
| Rq | RMS 평균 | Ra × 1.11 |
| Rz | 피크-밸리 평균 | 85-100 μm |
| Rsk | 비대칭도 | (1/Rq³)×∫Z³ |
| Rku | 첨도 | (1/Rq⁴)×∫Z⁴ |

### GLCM (Gray Level Co-occurrence Matrix) 분석

GLCM은 특정 거리(d)와 각도(θ)에서 픽셀 쌍의 회색조 관계를 행렬로 표현한다.

**Contrast (텍스처 변동)**: $Contrast = \sum_i \sum_j (i-j)^2 \times P(i,j)$

**Correlation (선형 종속성)**: $Correlation = \frac{\sum_i \sum_j [(i-\mu_i)(j-\mu_j) \times P(i,j)]}{\sigma_i \times \sigma_j}$

**Energy (균일성)**: $Energy = \sum_i \sum_j P(i,j)^2$

**Homogeneity (동질성)**: $Homogeneity = \sum_i \sum_j \frac{P(i,j)}{1 + |i-j|}$

**Entropy**: $Entropy = -\sum_i \sum_j P(i,j) \times \log_2[P(i,j)]$

피부 해석: **높은 Contrast**=거친 피부, **높은 Homogeneity**=매끄러운 피부, **높은 Energy**=규칙적 패턴

### LBP (Local Binary Pattern)

LBP는 중심 픽셀과 주변 픽셀의 비교를 이진 코드로 인코딩한다:

$$LBP(x_c, y_c) = \sum_{p=0}^{P-1} s(g_p - g_c) \times 2^p$$

$$s(x) = \begin{cases} 1, & x \geq 0 \\ 0, & x < 0 \end{cases}$$

**확장 LBP (원형 이웃)**: $LBP_{P,R}$ 여기서 R=반경, P=이웃 수(보통 8)

Uniform 패턴(≤2 비트 전환)으로 256개 패턴을 59개 빈으로 축소 가능. 조명 변화에 강건하며 피부 텍스처 품질 평가에 활용된다.

### Gabor Filter Bank

2D Gabor 필터 방정식:

$$g(x,y;\lambda,\theta,\psi,\sigma,\gamma) = \exp\left(-\frac{x'^2 + \gamma^2y'^2}{2\sigma^2}\right) \times \exp\left(i \times \left[\frac{2\pi x'}{\lambda} + \psi\right]\right)$$

$$x' = x\cos(\theta) + y\sin(\theta), \quad y' = -x\sin(\theta) + y\cos(\theta)$$

피부 분석 권장 설정: **Scales**: 4-5개 (σ=1,2,4,8,16), **Orientations**: 6-8개 (0°~157.5°)

### 측정 장비 및 표준

**PRIMOS (Phaseshift Rapid In vivo Measurement Of Skin)**: 3D 광학 프로파일로메트리, **수직 해상도 ~2 μm**, 피부 릴리프 측정 gold standard

**Visioscan VC 98**: UVA 조명 비디오 카메라, SEr(roughness), SEsm(smoothness), SEsc(scaliness), SEw(wrinkles) 파라미터 측정

**ICC 신뢰도**: Visioscan 0.50-0.95, PRIMOS 0.01-1.00 (Ra, Rz가 가장 신뢰성 높음)

---

## Roughness와 수분도 상관관계

### 핵심 연구 결과

피부 표면 거칠기와 수분도의 관계는 **복잡하고 측정 깊이에 따라 달라진다**. 일부 연구에서는 각질층 수분과 roughness 간 유의미한 상관관계가 없었으나, 다른 연구에서는 **각질층 최외곽 수분 함량과 roughness가 양의 상관관계**를 보였다.

**TEWL-텍스처 상관관계** (Koseki et al., 2020, n=244):
- TEWL vs. 텍스처 규칙성: **R² = 0.524** (랜덤 포레스트 예측 모델)
- 규칙적 텍스처(낮은 TEWL) vs. 불규칙/거친 텍스처(높은 TEWL) 명확히 구분됨
- TEWL과 피부 토폴로지 특성의 상관관계가 연령, 성별, 환경 요인보다 **더 강력함**

### 정량적 데이터

| 연구 | 파라미터 | 상관계수 | 유의성 |
|-----|---------|---------|-------|
| Koseki et al., 2020 | TEWL vs. 텍스처 | R² = 0.524 | p < 0.01 |
| 수분/광음향 | 수분 vs. 음향 | r = -0.87 | 유의함 |
| 나노메쉬 전극 | 수분 vs. 임피던스 | r = -0.86 | 유의함 |
| Hadi et al. | SC수분 vs. Roughness | **무상관** | - |

### 보습제 적용에 따른 roughness 변화

2주 보습제 사용 연구 (Ruini et al., 2022, n=20):

| 파라미터 | 기준선 T0 | 처리 후 T1 | 변화량 |
|---------|----------|----------|--------|
| Ra (처리군) | 15.46 ± 3.31 μm | 13.06 ± 2.78 μm | **-15.5%** |
| Rz (처리군) | 98.64 ± 18.53 μm | 85.38 ± 14.98 μm | **-13.4%** |
| Ra (대조군) | 14.51 μm | 13.90 μm | -4.2% |

8주 5% 요소 제품 사용: **Rz -12.2 μm 감소**, SC 수분 **+11.6 AU 증가**

### 메커니즘

수분 손실 시 각질층 효소 반응 저하 → 각질세포 박리 장애 → 축적 → 거칠고 각질화된 표면. 임계 수분 함량 이하로 떨어지면 정상적 탈락이 억제되어 건조하고 스케일링된 외관이 나타난다.

---

## T존/U존별 정상 범위

### 존별 기본 특성

| 특성 | T존 (이마, 코, 턱) | U존 (양 볼) |
|-----|------------------|------------|
| 피지선 밀도 | 400-900 glands/cm² | 낮음 |
| 모낭피지단위 | 200-300/cm² | 적음 |
| 피지 분비 | 높음, 불안정 | 낮음, 안정 |
| 모공 크기 | 크고 가시적 | 작고 덜 가시적 |
| 특징 | 번들거림, 여드름 | 건조 경향 |

### 피지 분비량 정상 범위 (Sebumeter®, μg/cm²)

| 부위 | 건성 | 정상 | 지성 |
|-----|-----|-----|-----|
| 이마 | <70 | 70-150 | >150-220+ |
| 볼 | <20-30 | 30-70 | >70-180+ |
| 턱 | <40 | 40-100 | >100+ |
| 코 | 변동적 | 변동적 | 변동적 |

피지 분비 속도 기준: **건성** <0.5-1 μg/cm²/min, **정상** 1-2 μg/cm²/min, **지성** >2-4 μg/cm²/min

### 모공 크기 정상 범위

| 분류 | 크기 (μm) | 면적 (mm²) |
|-----|----------|-----------|
| 작은 모공 | <40 | <0.05 |
| 보통 모공 | 40-70 | 0.05-0.10 |
| 큰 모공 | >70 | 0.10-0.20 |
| 확대된 모공 | - | >0.20-0.37 |

### 다민족 비교 데이터 (L'Oreal 연구, n=2,585)

| 민족 | 모공 면적 (mm²) | 밀도 (N/cm²) | 피부 점유율 |
|-----|----------------|--------------|------------|
| **중국인** | **0.03-0.06** | 10-25 | 1.2-1.5% |
| 일본인 | 0.14-0.19 | 67-72 | 9.6-13.4% |
| 코카시안 | 0.16-0.22 | 60-65 | 10.6-13.3% |
| 인도인 | 0.17-0.29 | 72-83 | 13.7-20.4% |
| 브라질인 | 0.23-0.37 | 62-91 | 20.7-22.8% |

**핵심 발견**: 아시아인(특히 중국인)이 다른 인종 대비 **가장 작은 모공 면적**

### 한국인 피부 분류 기준 (한국화장품산업연구원, n=434)

| 파라미터 | 측정값 | 피부 타입 |
|---------|--------|----------|
| TEWL | >18.0 g/m²/h | 민감성 |
| pH | >5.45 | 민감성 |
| 수분 (Corneometer) | <47.17 A.U. | 탈수 |
| 피지 (Sebumeter) | >70 μg/cm² | 지성 |
| 탄력 (Cutometer R2) | <0.68 E/mm | 이완/노화 |

### 한국인 vs 중국인 비교 (n=361)

| 파라미터 | 한국인 | 중국인 |
|---------|--------|--------|
| 수분 | 높음 | 낮음 |
| TEWL | 낮음 (피부장벽 우수) | 높음 |
| 피지 | 낮음 | 높음 |
| 주름 심각도 | 덜 심각 | 더 심각 |
| 피부 밝기 | 밝음 | 덜 밝음 |

---

## 구현 시 필수 체크리스트

### 이미지 획득 조건
- [ ] 조명: 균일한 확산광, 정면 조명 권장
- [ ] 해상도: 최소 768×576 픽셀 (Visioscan 기준)
- [ ] 색공간: BGR → 그레이스케일 변환
- [ ] ROI 설정: T존/U존 영역 별도 마스킹

### 전처리 단계
- [ ] CLAHE 적용 (clipLimit=2.0, tileGridSize=8×8)
- [ ] 가우시안 블러 (커널 5×5)
- [ ] 필요 시 Top-hat 변환으로 조명 보정

### 모공 감지 검증
- [ ] minArea/maxArea 피부 유형별 조정
- [ ] Circularity 임계값 0.6 이상 권장
- [ ] Ground truth 대비 IoU ≥ 0.35 확인

### Roughness 계산 검증
- [ ] Ra/Rq/Rz 단위 통일 (μm 또는 pixels)
- [ ] GLCM 거리/방향 파라미터 명시
- [ ] LBP radius/points 설정 기록

### 점수 정규화
- [ ] 연령/성별 보정 여부 결정
- [ ] 0-100 또는 0-1000 스케일 선택
- [ ] 기준값(baseline) 데이터베이스 구축

---

## TypeScript 코드 예시

### 모공 점수 계산

```typescript
interface Pore {
  center: { x: number; y: number };
  diameter: number;
  area: number;
  circularity: number;
  elongation: number;
}

interface PoreAnalysisResult {
  pores: Pore[];
  density: number;        // pores/cm²
  avgArea: number;        // mm²
  avgCircularity: number;
  visibilityScore: number; // 0-1000
}

function calculatePoreMetrics(
  pores: Pore[],
  roiAreaCm2: number
): PoreAnalysisResult {
  if (pores.length === 0) {
    return {
      pores: [],
      density: 0,
      avgArea: 0,
      avgCircularity: 0,
      visibilityScore: 0
    };
  }

  const density = pores.length / roiAreaCm2;
  const avgArea = pores.reduce((sum, p) => sum + p.area, 0) / pores.length;
  const avgCircularity = pores.reduce((sum, p) => sum + p.circularity, 0) / pores.length;
  
  // Visibility Score (0-1000): 밀도와 크기 기반
  // 가중치: 밀도 40%, 평균 면적 40%, 원형도 역수 20%
  const densityScore = Math.min(density * 4, 400);      // max 400
  const areaScore = Math.min(avgArea * 2000, 400);       // max 400
  const shapeScore = Math.min((1 - avgCircularity) * 200, 200); // max 200
  
  const visibilityScore = Math.round(densityScore + areaScore + shapeScore);

  return {
    pores,
    density,
    avgArea,
    avgCircularity,
    visibilityScore: Math.min(visibilityScore, 1000)
  };
}

// 원형도 계산
function calculateCircularity(area: number, perimeter: number): number {
  if (perimeter === 0) return 0;
  return (4 * Math.PI * area) / (perimeter * perimeter);
}

// 신장도 계산
function calculateElongation(majorAxis: number, minorAxis: number): number {
  if (minorAxis === 0) return 1;
  return majorAxis / minorAxis;
}
```

### Roughness 파라미터 계산

```typescript
interface RoughnessResult {
  Ra: number;  // 산술 평균 거칠기 (μm)
  Rq: number;  // RMS 거칠기 (μm)
  Rz: number;  // 최대 높이 (μm)
  Rsk: number; // 비대칭도
  Rku: number; // 첨도
}

function calculateRoughnessParameters(
  profile: number[],  // 높이 프로파일 (μm 단위)
  samplingLength: number
): RoughnessResult {
  const n = profile.length;
  const meanZ = profile.reduce((a, b) => a + b, 0) / n;
  
  // 평균선 기준 편차
  const deviations = profile.map(z => z - meanZ);
  
  // Ra: 절대편차 평균
  const Ra = deviations.reduce((sum, z) => sum + Math.abs(z), 0) / n;
  
  // Rq: RMS 거칠기
  const Rq = Math.sqrt(deviations.reduce((sum, z) => sum + z * z, 0) / n);
  
  // Rz: 5개 최대 피크 + 5개 최대 밸리 평균
  const sorted = [...deviations].sort((a, b) => b - a);
  const peaks = sorted.slice(0, 5);
  const valleys = sorted.slice(-5).map(v => Math.abs(v));
  const Rz = (peaks.reduce((a, b) => a + b, 0) + valleys.reduce((a, b) => a + b, 0)) / 5;
  
  // Rsk: 비대칭도
  const Rsk = deviations.reduce((sum, z) => sum + Math.pow(z, 3), 0) / (n * Math.pow(Rq, 3));
  
  // Rku: 첨도
  const Rku = deviations.reduce((sum, z) => sum + Math.pow(z, 4), 0) / (n * Math.pow(Rq, 4));
  
  return { Ra, Rq, Rz, Rsk, Rku };
}
```

### GLCM 특성 계산

```typescript
interface GLCMFeatures {
  contrast: number;
  correlation: number;
  energy: number;
  homogeneity: number;
  entropy: number;
}

function calculateGLCMFeatures(glcm: number[][]): GLCMFeatures {
  const size = glcm.length;
  let contrast = 0, energy = 0, homogeneity = 0, entropy = 0;
  let muI = 0, muJ = 0, sigmaI = 0, sigmaJ = 0, correlation = 0;
  
  // 정규화
  const total = glcm.flat().reduce((a, b) => a + b, 0);
  const normalizedGLCM = glcm.map(row => row.map(val => val / total));
  
  // 평균 계산
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      muI += i * normalizedGLCM[i][j];
      muJ += j * normalizedGLCM[i][j];
    }
  }
  
  // 표준편차 계산
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      sigmaI += Math.pow(i - muI, 2) * normalizedGLCM[i][j];
      sigmaJ += Math.pow(j - muJ, 2) * normalizedGLCM[i][j];
    }
  }
  sigmaI = Math.sqrt(sigmaI);
  sigmaJ = Math.sqrt(sigmaJ);
  
  // 특성 계산
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      const p = normalizedGLCM[i][j];
      
      // Contrast: Σ(i-j)² × P(i,j)
      contrast += Math.pow(i - j, 2) * p;
      
      // Energy: Σ P(i,j)²
      energy += p * p;
      
      // Homogeneity: Σ P(i,j) / (1 + |i-j|)
      homogeneity += p / (1 + Math.abs(i - j));
      
      // Entropy: -Σ P(i,j) × log₂(P(i,j))
      if (p > 0) {
        entropy -= p * Math.log2(p);
      }
      
      // Correlation
      if (sigmaI > 0 && sigmaJ > 0) {
        correlation += ((i - muI) * (j - muJ) * p) / (sigmaI * sigmaJ);
      }
    }
  }
  
  return { contrast, correlation, energy, homogeneity, entropy };
}
```

### LBP 계산

```typescript
function calculateLBP(
  image: number[][],  // 그레이스케일 이미지
  radius: number = 1,
  points: number = 8
): number[][] {
  const height = image.length;
  const width = image[0].length;
  const lbpImage: number[][] = Array(height).fill(0).map(() => Array(width).fill(0));
  
  for (let y = radius; y < height - radius; y++) {
    for (let x = radius; x < width - radius; x++) {
      const center = image[y][x];
      let lbpValue = 0;
      
      for (let p = 0; p < points; p++) {
        const angle = (2 * Math.PI * p) / points;
        const nx = x + radius * Math.cos(angle);
        const ny = y - radius * Math.sin(angle);
        
        // 이중선형 보간
        const neighborValue = bilinearInterpolate(image, nx, ny);
        
        // s(x) = 1 if x >= 0, else 0
        if (neighborValue >= center) {
          lbpValue += Math.pow(2, p);
        }
      }
      
      lbpImage[y][x] = lbpValue;
    }
  }
  
  return lbpImage;
}

function bilinearInterpolate(image: number[][], x: number, y: number): number {
  const x1 = Math.floor(x), x2 = Math.ceil(x);
  const y1 = Math.floor(y), y2 = Math.ceil(y);
  
  if (x2 >= image[0].length || y2 >= image.length) {
    return image[Math.min(y1, image.length - 1)][Math.min(x1, image[0].length - 1)];
  }
  
  const fx = x - x1, fy = y - y1;
  
  return (1 - fx) * (1 - fy) * image[y1][x1] +
         fx * (1 - fy) * image[y1][x2] +
         (1 - fx) * fy * image[y2][x1] +
         fx * fy * image[y2][x2];
}
```

### 종합 피부 텍스처 점수

```typescript
interface SkinTextureScore {
  poreScore: number;      // 0-100
  roughnessScore: number; // 0-100
  overallScore: number;   // 0-100
  hydrationEstimate: 'low' | 'normal' | 'high';
  skinType: 'dry' | 'normal' | 'oily' | 'combination';
}

function calculateOverallTextureScore(
  poreResult: PoreAnalysisResult,
  roughnessResult: RoughnessResult,
  zone: 'T' | 'U',
  sebumLevel: number  // μg/cm²
): SkinTextureScore {
  // 모공 점수 정규화 (0-100, 낮을수록 좋음 → 높을수록 좋음 변환)
  const poreScore = 100 - Math.min(poreResult.visibilityScore / 10, 100);
  
  // Roughness 점수 (Ra 기준, 13-60 μm → 0-100)
  // 낮은 Ra = 매끄러움 = 높은 점수
  const raMin = 13, raMax = 60;
  const normalizedRa = Math.max(0, Math.min(1, (roughnessResult.Ra - raMin) / (raMax - raMin)));
  const roughnessScore = Math.round((1 - normalizedRa) * 100);
  
  // 수분 상태 추정 (Ra 기반)
  let hydrationEstimate: 'low' | 'normal' | 'high';
  if (roughnessResult.Ra > 40) hydrationEstimate = 'low';
  else if (roughnessResult.Ra < 25) hydrationEstimate = 'high';
  else hydrationEstimate = 'normal';
  
  // 피부 타입 판정
  let skinType: 'dry' | 'normal' | 'oily' | 'combination';
  const sebumThresholds = zone === 'T' 
    ? { low: 70, high: 150 }  // T존 기준
    : { low: 30, high: 70 };  // U존 기준
  
  if (sebumLevel < sebumThresholds.low) skinType = 'dry';
  else if (sebumLevel > sebumThresholds.high) skinType = 'oily';
  else skinType = 'normal';
  // combination은 T존/U존 별도 분석 후 판정 필요
  
  // 종합 점수 (모공 40%, roughness 60%)
  const overallScore = Math.round(poreScore * 0.4 + roughnessScore * 0.6);
  
  return {
    poreScore,
    roughnessScore,
    overallScore,
    hydrationEstimate,
    skinType
  };
}
```

---

## 결론: 핵심 인사이트

피부 텍스처 분석 시스템 구현 시 **다중 메트릭 접근법**이 필수적이다. 단일 파라미터로는 피부 상태를 정확히 평가할 수 없으며, 모공(크기/밀도/형태) + roughness(Ra/Rq/Rz) + 텍스처(GLCM/LBP)의 조합이 가장 신뢰성 있는 결과를 제공한다.

**TEWL이 roughness보다 수분 상태의 더 강력한 예측 인자**(R²=0.524)라는 점은 barrier function 평가의 중요성을 시사한다. 보습제 2주 사용으로 Ra가 **15.5% 감소**한다는 정량적 데이터는 치료 효과 모니터링의 벤치마크로 활용 가능하다.

한국인/아시아인은 다른 인종 대비 **가장 작은 모공 면적**(0.03-0.06 mm²)을 보이므로, 민족 특화 기준값 적용이 필수적이다. T존과 U존의 피지 분비량 차이(2-3배)를 고려한 영역별 분석이 복합성 피부 진단의 핵심이다.