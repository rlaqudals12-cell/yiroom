# 이룸 시스템 아키텍처

> 확장성, 유연성, 캡슐 엔진 기반 아키텍처 설계
>
> **핵심 원칙**: "어떤 상황에서도 대안이 있는 유연한 시스템"

---

## 0. 궁극의 형태 (P1)

### 이상적 최종 상태

```
"사용자의 모든 외적/내적 데이터를 통합하여,
어떤 상황에서도 개인화된 최적의 추천을 제공하는
자기 적응형 웰니스 AI 플랫폼"
```

| 영역 | 궁극의 형태 |
|------|------------|
| **분석 정확도** | AI 분석 신뢰도 95%+, 전문가 수준 일치율 |
| **응답 속도** | 모든 분석 1초 이내, 실시간 피드백 |
| **가용성** | 99.99% 업타임, 0% 데이터 손실 |
| **복원력** | 어떤 장애에도 서비스 무중단 (완벽한 Fallback) |
| **확장성** | 1억 사용자, 글로벌 다국어, 무한 모듈 확장 |
| **개인화** | 사용자별 완전 맞춤형 UX, 선호도 자동 학습 |
| **통합** | 모든 웰니스 영역 (피부+체형+영양+운동+정신) 융합 인사이트 |

### 물리적 한계

| 제약 | 설명 | 대응 |
|------|------|------|
| **AI 지연** | Gemini API 평균 2-5초 | 3단계 Fallback, Mock 대응 |
| **비용** | AI 호출당 비용 발생 | Rate Limiting (50회/24h) |
| **데이터 의존성** | 외부 API (Clerk, Supabase) | Multi-provider 전략 |
| **이미지 품질** | 사용자 환경 통제 불가 | CIE 전처리, 재촬영 안내 |
| **의료 한계** | 의료 행위 불가 (법적) | 정보 제공 + 전문가 권유 |

### 100점 기준

```markdown
## 정량적 기준

| 지표 | 100점 기준 | 측정 방법 |
|------|-----------|----------|
| AI 분석 응답 | < 1초 | p95 latency |
| 페이지 로드 (LCP) | < 1.5초 | Lighthouse |
| 분석 정확도 | 95%+ | 전문가 블라인드 비교 |
| 시스템 가용성 | 99.99% | 월간 다운타임 < 4분 |
| Fallback 성공률 | 100% | AI 장애 시 서비스 지속 |
| 번들 크기 | < 300KB | gzip 압축 후 |
| 테스트 커버리지 | 90%+ | lib/ 기준 |

## 정성적 기준

| 영역 | 100점 기준 |
|------|-----------|
| 사용자 경험 | "분석이 나보다 나를 더 잘 안다" |
| 추천 만족도 | 추천 상품/루틴 90%+ 채택률 |
| 복원력 | 사용자가 장애를 인지하지 못함 |
| 확장성 | 새 분석 타입 추가에 1일 이내 |
```

### 현재 달성도

```
전체: 약 65%

| 영역 | 달성도 | 설명 |
|------|--------|------|
| 분석 엔진 (PC/S/C) | 80% | 7개 분석 타입 완료, 정확도 개선 여지 |
| 캡슐 엔진 | 60% | 기본 로직 완성, 인벤토리 연동 진행 중 |
| 복원력 (Fallback) | 75% | 3단계 Fallback 구현, 알림 UI 미완 |
| 성능 | 60% | LCP 2.5s 달성, 1.5s 목표 미달 |
| 확장성 | 50% | 수평 확장 미검증, 단일 리전 |
| 글로벌 | 10% | 한국어 전용, 다국어 미구현 |
| 모듈 확장성 | 70% | OCP 패턴 적용 중, 레지스트리 일부 구현 |
```

### 의도적 제외

| 제외 항목 | 이유 | 재검토 시점 |
|----------|------|------------|
| **Multi-region 배포** | 현재 한국 타겟, 트래픽 미충분 | MAU 10만+ 달성 시 |
| **자체 AI 모델** | Gemini 비용 효율적, 학습 데이터 부족 | 분석 100만건+ 축적 시 |
| **실시간 영상 분석** | 기술 복잡도, 비용 | Phase 5+ |
| **의료 진단 기능** | 법적 규제, 책임 문제 | 의료 파트너십 시 |
| **오프라인 완전 지원** | PWA 구현 복잡도 | 모바일 앱 안정화 후 |
| **외부 앱 연동** | API 개방 리소스 부족 | Phase 4+ |

---

## 1. 아키텍처 개요

### 1.1 핵심 철학

```
캡슐 아키텍처 = 최소한의 핵심 + 무한한 조합 + 항상 대안
```

| 원칙 | 설명 | 적용 |
|------|------|------|
| **최소 핵심** | 핵심 기능은 단순하게 | 분석 엔진 3개 (PC, S, C) |
| **무한 조합** | 핵심 조합으로 다양한 결과 | 퍼스널컬러 × 체형 × 얼굴형 |
| **항상 대안** | 실패 시 항상 Fallback | AI 실패 → Mock → 캐시 |

### 1.2 시스템 계층

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│    Next.js (웹) / Expo (모바일) / 공유 컴포넌트               │
├─────────────────────────────────────────────────────────────┤
│                    Application Layer                         │
│    캡슐 엔진 / 분석 엔진 / 추천 엔진 / 인벤토리 엔진          │
├─────────────────────────────────────────────────────────────┤
│                    Domain Layer                              │
│    퍼스널컬러 / 피부분석 / 체형분석 / 얼굴형 / 영양           │
├─────────────────────────────────────────────────────────────┤
│                    Infrastructure Layer                      │
│    Supabase / Clerk / Gemini AI / Storage                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 캡슐 엔진 아키텍처

### 2.1 캡슐 엔진 개념

> 출처: 패션의 "캡슐 워드로브" (적은 아이템으로 다양한 코디)

```
문제: "계획대로 안 됨" → 기구 없음, 시간 없음, 재료 없음
해결: "어떤 상황에서도 할 수 있는 유연한 시스템"
     → 대체가 아니라 "상황 적응형 시스템"
```

### 2.2 캡슐 엔진 로직

```typescript
interface CapsuleEngine<T> {
  // 입력: 사용자 인벤토리 + 요청
  findOptions(inventory: T[], request: Request): CapsuleResult;
}

interface CapsuleResult {
  primary: Option;           // 1순위 추천 (보유 아이템 기반)
  alternatives: Option[];    // 대체 옵션 N개
  missing: Item[];           // 부족한 아이템 (구매 추천)
}
```

### 2.3 영역별 캡슐 적용

| 영역 | Input | Primary | Alternatives | Missing |
|------|-------|---------|--------------|---------|
| **패션** | 옷장 인벤토리 | 보유 아이템 코디 | 대체 조합 3개 | 추가 구매 추천 |
| **운동** | 보유 기구 | 기구 활용 루틴 | 맨몸 대체 | 기구 구매 추천 |
| **영양** | 보유 재료 | 재료 활용 레시피 | 대체 재료 | 식재료 추천 |
| **스킨케어** | 보유 제품 | 제품 활용 루틴 | 성분 기반 대체 | 제품 구매 추천 |

### 2.4 캡슐 엔진 상태 다이어그램

```
[사용자 요청]
     │
     ▼
[인벤토리 조회]
     │
     ├─ 충분함 ─────────────► [1순위 추천 생성]
     │                              │
     │                              ▼
     │                        [결과 반환]
     │
     └─ 부족함 ─────────────► [대체 옵션 탐색]
                                    │
                                    ├─ 대체 가능 ──► [대체 추천]
                                    │                    │
                                    │                    ▼
                                    │              [결과 + 대체]
                                    │
                                    └─ 대체 불가 ──► [구매 추천]
                                                         │
                                                         ▼
                                                   [결과 + 추천]
```

---

## 3. 확장성 전략

### 3.1 수평 확장 (Scale Out)

| 계층 | 현재 | 확장 시 |
|------|------|---------|
| **웹** | Vercel Serverless | Edge Functions |
| **DB** | Supabase (단일) | Read Replicas |
| **AI** | Gemini Flash | Multi-model Fallback |
| **Storage** | Supabase Storage | CDN + 리전별 캐시 |

### 3.2 기능 확장 (Feature Scale)

```
Phase 1-2: 핵심 분석 (PC, S, C)
     │
     ▼
Phase 3: 확장 모듈 (피부시술, 구강건강, 고급 스트레칭)
     │
     ▼
Phase 4-5: 고도화 (E2E, 접근성, 성능, 문서화)
     │
     ▼
Phase 5A: UX 트렌드 반영
```

### 3.3 글로벌 확장 (향후)

| 단계 | 범위 | 고려사항 |
|------|------|----------|
| 1 | 한국 전용 | 한국어, KST |
| 2 | 아시아 확장 | 일본어, 중국어, 다국어 |
| 3 | 글로벌 | 영어, 리전별 데이터 |

---

## 4. 복원력 (Resilience)

### 4.1 3단계 Fallback 체계

```
Level 1: 재시도 (Retry)
   │
   └─ 실패 ─► Level 2: 대체 처리 (Fallback)
                  │
                  └─ 실패 ─► Level 3: 우아한 실패 (Graceful Degradation)
```

### 4.2 AI 분석 Fallback

```typescript
async function analyzeWithFallback<T>(
  analyze: () => Promise<T>,
  fallbackChain: FallbackChain<T>
): Promise<CapsuleResult<T>> {
  // Level 1: 캐시 확인
  const cached = await cache.get(key);
  if (cached) return { result: cached, source: 'cache' };

  // Level 2: AI 분석 시도 (재시도 포함)
  try {
    const result = await withRetry(analyze, { maxRetries: 2 });
    return { result, source: 'ai' };
  } catch {
    // Level 3: 대체 AI
    try {
      const altResult = await fallbackChain.alternativeAI();
      return { result: altResult, source: 'alternative_ai' };
    } catch {
      // Level 4: Mock 데이터
      const mock = fallbackChain.generateMock();
      return { result: mock, source: 'mock', isApproximate: true };
    }
  }
}
```

### 4.3 Fallback 알림 정책

| Source | 사용자 알림 | UI 표시 |
|--------|------------|---------|
| `ai` | 없음 | 정상 |
| `cache` | 없음 | 정상 |
| `alternative_ai` | 선택적 | 정상 |
| `mock` | **필수** | "예상 결과" 배지 |

---

## 5. 데이터 흐름

### 5.1 분석 파이프라인

```
[이미지 입력]
     │
     ▼
[CIE: 이미지 품질 검증] ──► 실패 ──► [재촬영 안내]
     │
     ▼ 성공
[CIE: 전처리] (리사이즈, 색보정)
     │
     ▼
[분석 엔진 호출] (PC/S/C 병렬)
     │
     ├── [PC 분석] ──► 퍼스널컬러 결과
     ├── [S 분석] ──► 피부 결과
     └── [C 분석] ──► 체형 결과
     │
     ▼
[결과 통합] (캡슐 매트릭스)
     │
     ▼
[추천 생성] (캡슐 엔진)
     │
     ▼
[결과 저장 + 반환]
```

### 5.2 데이터 저장 구조

```
사용자 데이터
├── profiles (기본 정보)
├── analysis_results (분석 결과)
│   ├── personal_color_assessments
│   ├── skin_assessments
│   └── body_assessments
├── inventory (인벤토리)
│   ├── wardrobe_items
│   ├── skincare_products
│   └── equipment
└── recommendations (추천 이력)
```

---

## 6. 모듈 의존성

### 6.1 핵심 모듈 의존성

```
                    ┌─────────────┐
                    │   CIE 엔진   │
                    │ (이미지 처리) │
                    └──────┬──────┘
                           │
         ┌─────────────────┼─────────────────┐
         ▼                 ▼                 ▼
   ┌──────────┐     ┌──────────┐     ┌──────────┐
   │  PC-1    │     │   S-1    │     │   C-1    │
   │퍼스널컬러│     │ 피부분석 │     │ 체형분석 │
   └────┬─────┘     └────┬─────┘     └────┬─────┘
        │                │                │
        └────────────────┼────────────────┘
                         ▼
                   ┌──────────┐
                   │ 캡슐 엔진 │
                   │ (통합 추천) │
                   └──────────┘
```

### 6.2 확장 모듈 (Phase 3+)

```
캡슐 엔진
    │
    ├── SK-1: 피부시술 추천
    ├── OH-1: 구강건강
    └── W-2: 고급 스트레칭
```

---

## 7. 보안 아키텍처

### 7.1 인증/인가 계층

```
[요청]
   │
   ▼
[Clerk 인증] ──► 실패 ──► 401 Unauthorized
   │
   ▼ 성공
[RLS 정책] ──► 본인 데이터만 접근
   │
   ▼
[API 처리]
```

### 7.2 데이터 보호

| 데이터 유형 | 보호 방법 |
|------------|----------|
| 이미지 | 서명된 URL (1시간 만료) |
| 분석 결과 | RLS + clerk_user_id |
| 개인정보 | 암호화 저장 |
| 로그 | PII 마스킹 |

---

## 8. 성능 목표

### 8.1 SLA 정의

| 지표 | 목표 | 경고 | 심각 |
|------|------|------|------|
| API 응답 (일반) | < 500ms | > 1s | > 2s |
| AI 분석 | < 3s | > 5s | > 10s |
| 페이지 로드 (LCP) | < 2.5s | > 3s | > 4s |

### 8.2 성능 최적화 전략

| 계층 | 전략 |
|------|------|
| **프론트엔드** | Dynamic import, 이미지 최적화, 가상화 |
| **API** | 캐싱, 병렬 처리, 타임아웃 |
| **DB** | 인덱스, 쿼리 최적화, limit |
| **AI** | 이미지 전처리, 타임아웃, Fallback |

---

## 9. 관련 문서

| 문서 | 설명 |
|------|------|
| [USER-FLOWS.md](./USER-FLOWS.md) | 사용자 행동 경우의 수 |
| [TECH-DECISIONS.md](./TECH-DECISIONS.md) | 기술 선택 및 교체 전략 |
| [DATABASE-SCHEMA.md](./DATABASE-SCHEMA.md) | DB 스키마 |
| `.claude/rules/` | 코딩 규칙 |

---

**Version**: 1.1 | **Created**: 2026-01-16 | **Updated**: 2026-01-23 | P1 섹션 추가
