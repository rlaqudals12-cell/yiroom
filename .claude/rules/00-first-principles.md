# 제1원칙 (First Principles)

> 이룸 프로젝트의 최우선 규칙. 모든 작업은 이 원칙에서 시작한다.
> 이 문서는 다른 모든 규칙보다 우선한다.

---

## 원리의 근거

이 원칙은 **일론 머스크의 "5단계 엔지니어링 알고리즘"**에서 파생되었다:

```
머스크 원칙 (2021, SpaceX/Tesla):
1. 요구사항을 의심하라 - 모든 요구사항은 누군가의 이름이 붙어야 한다
2. 프로세스/부품을 삭제하라 - 나중에 10% 추가하지 않으면 충분히 삭제하지 않은 것
3. 단순화/최적화하라 - 단, 1-2단계 후에만
4. 사이클 시간을 가속하라 - 단, 1-3단계 후에만
5. 자동화하라 - 단, 1-4단계 후에만
```

### 이룸 프로젝트 대응

| 머스크 원칙      | 이룸 대응       | 확장/변형                                           |
| ---------------- | --------------- | --------------------------------------------------- |
| 1. 요구사항 의심 | **P0** + **P1** | 궁극의 형태 정의 추가                               |
| 2. 삭제          | **P3**          | 원자 분해로 삭제 대상 식별                          |
| 3. 단순화        | **P4**          | 동일                                                |
| 4. 가속          | **P5**          | 동일                                                |
| 5. 자동화        | **P6**          | 동일                                                |
| (추가)           | **P2**          | 이룸 도메인 특성 (색채학, 피부생리학 등)            |
| (추가)           | **P7**          | 워크플로우 순서 (리서치 → 원리 → ADR → 스펙 → 구현) |
| (추가)           | **P8**          | 모듈 경계 (캡슐화, 단방향 의존성)                   |

**P2(원리 우선)**는 이룸의 도메인 특성을 반영한 추가 원칙이다.
**P7(워크플로우 순서)**는 순서 위반으로 인한 기술부채를 방지하는 원칙이다.
**P8(모듈 경계)**는 대규모 코드베이스의 유지보수성을 보장하는 원칙이다.
AI 분석 앱의 특성상, 도메인 원리(색채학, 피부생리학)를 이해하지 않으면 올바른 구현이 불가능하기 때문이다.

---

## 핵심 철학

```
"단순한 작업"이란 존재하지 않는다.
"단순해 보이는 작업"만 존재할 뿐이다.

Gate를 건너뛰는 것 ≠ Gate를 빠르게 통과하는 것
진정으로 단순한 것은 빠르게 통과한다.
단순해 보이지만 복잡한 것은 Gate에서 걸린다.
이것이 Gate의 가치다.
```

---

## P0: 요구사항 의심 (Question Requirements)

> "가장 큰 실수는 틀린 질문에 완벽히 답하는 것이다"

### 질문 (반드시 답변)

1. **이 요구사항이 틀렸다면?**
   - 요구사항 자체가 잘못된 가정에 기반할 수 있다
   - "왜?"를 최소 3번 질문한다

2. **이것을 완전히 삭제하면?**
   - 가장 좋은 코드는 작성하지 않는 코드
   - 삭제해도 목표 달성 가능한가?

3. **누가 이것을 요구했고, 왜?**
   - 요구의 출처와 근거를 추적한다
   - 근거 없는 요구는 의심한다

### 실행

```
모든 요구사항 → "왜?" 3회 질문 → 삭제 가능한 것 삭제 → 남은 것만 다음 단계
```

---

## P1: 궁극의 형태 정의 (Define Ultimate Form)

> "목적지를 모르면 어떤 길도 옳다"

### 질문 (반드시 답변)

1. **이 기능의 이상적 최종 상태는?**
   - 제약이 없다면 어떤 모습인가?
   - 100점 만점이라면?

2. **물리적/논리적 한계선은?**
   - 기술적으로 불가능한 것은?
   - 비용/시간 제약은?

3. **현재 구현은 궁극의 몇 %인가?**
   - 명시적으로 퍼센티지 기록
   - 부족한 부분이 의도적 선택인지 기록

### 실행

```
구현 전 → 궁극의 형태 문서화 → 현재 목표 % 설정 → 구현 → 달성 % 기록
```

### 문서화 형식

```markdown
## [기능명] 궁극의 형태

### 이상적 최종 상태

[제약 없는 완벽한 상태 설명]

### 물리적 한계

[기술적/비용적 제약]

### 100점 기준

[구체적 측정 가능한 기준]

### 현재 목표

[이번 구현에서 달성할 %]

### 의도적 제외

[이번에 하지 않는 것과 그 이유]
```

---

## P2: 원리 우선 (Principles First)

> "원리를 모르면 응용할 수 없다"

### 질문 (반드시 답변)

1. **이 도메인의 기본 원리는?**
   - 색채학, 피부생리학, 체형역학 등
   - 학문적/과학적 근거는?

2. **원리에서 구현을 도출할 수 있는가?**
   - 원리 → 알고리즘 → 코드 흐름이 명확한가?
   - 코드가 원리의 구현체인가?

3. **구현이 원리를 위반하지 않는가?**
   - 편의를 위해 원리를 무시하지 않았는가?
   - 위반 시 명시적 문서화 필요

### 실행

```
원리 문서화 (docs/principles/) → 원리에서 알고리즘 도출 → 알고리즘 구현 → 원리 준수 검증
```

### 원리 문서 위치

```
docs/principles/
├── color-science.md       # 색채학 (PC-1)
├── skin-physiology.md     # 피부 생리학 (S-1)
├── body-mechanics.md      # 체형 역학 (C-1)
├── image-processing.md    # 이미지 처리
├── ai-inference.md        # AI 추론
└── [domain].md            # 새 도메인 추가 시
```

---

## P3: 원자 분해 (Atomic Decomposition)

> "복잡한 것은 단순한 것의 조합이다"

### 질문 (반드시 답변)

1. **독립적으로 테스트 가능한 최소 단위는?**
   - 다른 것에 의존하지 않고 검증 가능한가?
   - 단일 책임을 가지는가?

2. **각 원자의 입력/출력/성공 기준은?**
   - 입력: 무엇을 받는가?
   - 출력: 무엇을 반환하는가?
   - 성공: 어떻게 성공을 판단하는가?

3. **원자 간 의존성 그래프는?**
   - A → B → C 순서가 명확한가?
   - 병렬 실행 가능한 것은?

### 실행

```
작업 정의 → 원자 분해 (각 1-2시간) → 의존성 그래프 작성 → 순서대로 실행 → 각 원자 테스트
```

### 원자 정의 형식

```markdown
## [원자 ID]: [원자명]

- 소요시간: X시간
- 입력: [입력 스펙]
- 출력: [출력 스펙]
- 성공 기준: [테스트 가능한 기준]
- 의존성: [선행 원자 ID]
```

---

## P4: 단순화 (Simplify)

> "완벽은 더할 것이 없을 때가 아니라 뺄 것이 없을 때"

### 질문 (반드시 답변)

1. **이것을 제거하면?**
   - 각 줄, 각 함수, 각 파일에 대해
   - 제거해도 동작하면 제거한다

2. **더 단순한 방법은?**
   - 같은 결과를 더 적은 코드로?
   - 더 적은 의존성으로?

3. **코드 없이 해결 가능한가?**
   - 설정으로 해결?
   - 기존 라이브러리 활용?
   - 요구사항 자체를 변경?

### 실행

```
구현 완료 → 각 부분 "제거하면?" 질문 → 제거 가능한 것 제거 → "더 단순하게?" → 반복
```

### 단순화 체크리스트

```
□ 모든 import가 사용되는가?
□ 모든 함수가 호출되는가?
□ 모든 변수가 사용되는가?
□ 중복 코드가 없는가?
□ 추상화가 과도하지 않은가?
□ 설정으로 대체 가능한 코드가 없는가?
```

---

## P5: 속도 (Accelerate)

> "느리게 가면 빨리 도착한다" — 단, P0-P4 완료 후에만

### ⚠️ 전제조건

```
P0-P4가 완료되지 않은 상태에서 속도를 내면:
- 틀린 방향으로 빠르게 감
- 기술부채 가속
- 나중에 더 느려짐

올바른 방향을 확인한 후에만 속도를 낸다.
```

### 질문 (P0-P4 완료 후)

1. **병목은 어디인가?**
   - 가장 느린 부분은?
   - 대기 시간은?

2. **병렬화 가능한가?**
   - 독립적인 원자는 동시 실행
   - I/O 대기 중 다른 작업

3. **대기 시간을 제거할 수 있는가?**
   - 비동기 처리
   - 캐싱
   - 사전 계산

---

## P6: 자동화 (Automate)

> "반복은 자동화의 신호다" — 단, P0-P5 완료 후에만

### ⚠️ 전제조건

```
잘못된 것을 자동화하면 잘못이 가속된다.
P0-P5로 검증된 것만 자동화한다.
```

### 질문 (P0-P5 완료 후)

1. **이것이 3번 이상 반복되는가?**
   - 1-2번: 수동 실행
   - 3번+: 자동화 검토

2. **자동화 비용 < 수동 비용인가?**
   - 자동화 구축 시간
   - 유지보수 비용
   - 수동 실행 누적 시간

3. **자동화가 복잡성을 숨기는가?**
   - 숨겨진 복잡성은 나중에 폭발
   - 투명한 자동화만 허용

---

## P7: 워크플로우 순서 (Workflow Order)

> "순서를 지키지 않으면 기술부채가 된다"

### 필수 순서

```
리서치 → 원리 문서화 → ADR → 스펙 → 구현
```

이 순서는 **절대적**이다. 어떤 작업도 이 순서를 건너뛸 수 없다.

### 각 단계 설명

| 단계            | 산출물                              | 목적                                          |
| --------------- | ----------------------------------- | --------------------------------------------- |
| **리서치**      | `docs/research/claude-ai-research/` | 도메인 지식, 학술 자료, 기술 스펙 조사        |
| **원리 문서화** | `docs/principles/`                  | 리서치 결과를 원리로 정리, 수학적/과학적 근거 |
| **ADR**         | `docs/adr/`                         | 기술 선택 결정, 대안 기록, 원리 문서 참조     |
| **스펙**        | `docs/specs/`                       | 입출력 정의, Mock 데이터, 인터페이스          |
| **구현**        | `apps/`, `packages/`                | 코드 작성, 테스트, typecheck + lint           |

### 질문 (반드시 답변)

1. **리서치가 완료되었는가?**
   - 도메인 지식이 충분한가?
   - 참고 자료가 문서화되었는가?

2. **원리가 문서화되었는가?**
   - `docs/principles/`에 관련 문서가 존재하는가?
   - 원리에서 알고리즘을 도출할 수 있는가?

3. **ADR이 작성되었는가?**
   - 기술 선택의 근거가 기록되었는가?
   - 대안과 trade-off가 명시되었는가?

4. **스펙이 확정되었는가?**
   - 입력/출력이 명확한가?
   - Mock 데이터가 정의되었는가?

### 순서 위반 시

```
순서 위반 = 기술부채

구현 먼저 → 나중에 ADR/스펙 = 소급 문서화 필요
리서치 없이 구현 = 잘못된 가정에 기반한 코드

위반 발견 시:
1. 즉시 중단
2. 누락된 단계 수행
3. 기존 구현과 스펙 비교
4. 불일치 시 수정
```

### 실행

```
작업 시작 전 → 5단계 체크 → 누락 시 해당 단계부터 시작 → 순서대로 진행
```

### 문서 위치 요약

```
docs/
├── research/
│   └── claude-ai-research/   # 리서치 결과
├── principles/               # 원리 문서
├── adr/                      # Architecture Decision Records
└── specs/                    # 스펙 문서 (SDD)
```

---

## P8: 모듈 경계 (Module Boundaries)

> "모듈은 검은 상자(Black Box)여야 한다"

### 핵심 원칙

```
외부는 공개 API만 알고, 내부 구현은 모른다.
모듈 간 의존성은 단방향이어야 한다.
```

### 질문 (반드시 답변)

1. **이 모듈의 공개 API는 무엇인가?**
   - index.ts에 export된 것만 공개 API
   - 내부 구현은 internal/ 폴더에 격리

2. **의존성 방향이 올바른가?**
   - Presentation → Domain → Repository 순서
   - 역방향 호출 금지

3. **순환 의존성이 있는가?**
   - A → B → A 패턴 금지
   - 공통 모듈(shared/)로 분리

### 모듈 구조

```
lib/[domain]/
├── index.ts          # 공개 API (Barrel Export)
├── types.ts          # 공개 타입
└── internal/         # 내부 구현 (외부 접근 금지)
    ├── utils.ts
    └── helpers.ts
```

### 호출 방향 규칙

```
┌──────────────┐
│ Presentation │  components/, app/
│    (UI)      │
└──────┬───────┘
       │ 호출 ↓
┌──────▼───────┐
│   Domain     │  lib/[domain]/
│  (비즈니스)   │
└──────┬───────┘
       │ 호출 ↓
┌──────▼───────┐
│ Repository   │  lib/supabase/, lib/gemini/
│  (데이터)     │
└──────────────┘

❌ 역방향 호출 금지
```

### 허용/금지 패턴

```typescript
// ✅ 허용: index.ts를 통한 import
import { calculateCalories } from '@/lib/workout';

// ❌ 금지: 내부 파일 직접 import
import { helper } from '@/lib/workout/internal/helpers';
```

### 상세 규칙

> 상세 규칙은 [encapsulation.md](./encapsulation.md) 참조

---

## 품질 게이트 (Quality Gates)

모든 작업은 다음 Gate를 통과해야 한다. Gate를 건너뛰지 않는다.

| Gate   | 질문                         | 통과 기준                           |
| ------ | ---------------------------- | ----------------------------------- |
| **G0** | 정말 필요한가? (P0)          | 삭제 불가능 증명 또는 명확한 근거   |
| **G1** | 궁극의 형태 정의됐나? (P1)   | 문서화 완료                         |
| **G2** | 원리 문서화됐나? (P2)        | docs/principles/ 존재               |
| **G3** | 원자 분해됐나? (P3)          | 각 원자 2시간 이내, 테스트 가능     |
| **G4** | 더 단순화 가능한가? (P4)     | 불가능 증명                         |
| **G5** | 테스트 있는가?               | 각 원자에 테스트 존재               |
| **G6** | 워크플로우 순서 지켰나? (P7) | 리서치→원리→ADR→스펙→구현           |
| **G7** | 모듈 경계 준수했나? (P8)     | index.ts 통한 import, 단방향 의존성 |

### Gate 통과 시간

```
Gate는 항상 적용된다. 통과 시간은 자연스럽게 달라진다.

예시:
| 작업 | G0 통과 시간 | 이유 |
|------|-------------|------|
| 버튼 색상 변경 | 5초 | "디자인 요청, 필요함" |
| 새 분석 모듈 추가 | 30분 | 요구사항 깊이 검토 필요 |
| 아키텍처 변경 | 2시간 | 영향 범위 분석 필요 |

시간이 오래 걸리는 것은 Gate가 느린 게 아니라,
작업이 실제로 복잡한 것이다.
```

---

## 금지 패턴 (Anti-Patterns)

| 패턴                        | 왜 금지되는가                             |
| --------------------------- | ----------------------------------------- |
| Gate 건너뛰기               | "단순해 보이는" 작업의 숨겨진 복잡성 놓침 |
| "나중에 정리"               | 나중은 오지 않음, 기술부채 누적           |
| 원리 없는 코드              | 유지보수 불가, "왜 이렇게 했지?"          |
| 궁극 없는 구현              | 방향 상실, 점진적 개선 불가               |
| 분해 없는 큰 작업           | 진행 추적 불가, 테스트 불가               |
| P0-P4 전 속도 내기          | 틀린 방향으로 가속                        |
| 검증 전 자동화              | 잘못의 가속                               |
| **워크플로우 순서 위반**    | 소급 문서화, 잘못된 가정 기반 코드        |
| **구현 먼저 ADR/스펙 나중** | 스펙과 구현 불일치, 수정 비용 증가        |
| **내부 파일 직접 import**   | 모듈 경계 위반, 리팩토링 어려움           |
| **순환 의존성**             | 빌드 실패, 테스트 격리 불가               |
| **역방향 호출**             | 계층 구조 파괴, 의존성 그래프 복잡화      |

---

## 되돌림 가능성 (Reversibility)

### 결정 분류

| 유형       | 특성           | 접근법                     |
| ---------- | -------------- | -------------------------- |
| **Type 1** | 되돌릴 수 없음 | 모든 Gate 신중하게         |
| **Type 2** | 되돌릴 수 있음 | Gate는 동일, 속도는 빠르게 |

### 예시

```
Type 1 (신중하게):
- DB 스키마 삭제
- 공개 API 변경
- 데이터 마이그레이션

Type 2 (빠르게 실험):
- UI 색상/레이아웃
- 내부 리팩토링
- 새 기능 프로토타입
```

---

## 완전성 체크리스트

기능이 "완전"하려면 다음을 모두 만족:

```
□ P0: 요구사항이 검증됨 (왜? 3회)
□ P1: 궁극의 형태가 문서화됨
□ P1: 현재 구현이 궁극의 몇 %인지 명시됨
□ P1: 부족한 부분이 의도적 선택으로 기록됨
□ P2: 관련 원리가 docs/principles/에 문서화됨
□ P3: 모든 원자가 정의되고 테스트됨
□ P4: 더 단순화할 수 없음이 확인됨
□ P7: 워크플로우 순서 준수됨 (리서치→원리→ADR→스펙→구현)
□ P8: 모듈 경계 준수됨 (index.ts export, 단방향 의존성)
□ G0-G7: 모든 Gate 통과됨
```

---

## 적용 예시

### CIE-1 (이미지 품질 검증)에 이 원칙 적용

```
P0 요구사항 의심:
├── "왜 이미지 품질을 검증해야 하나?"
│   → AI 분석의 신뢰도가 입력 품질에 의존하기 때문
├── "검증 없이 진행하면?"
│   → 저화질 이미지에서 잘못된 분석 결과
└── "삭제 가능한가?"
    → 불가능, 필수 기능

P1 궁극의 형태:
├── 이상적 상태: 100% 신뢰할 수 있는 이미지만 분석
├── 물리적 한계: 카메라 하드웨어, 조명 환경
├── 100점 기준: sharpness 40+, 자연광, 정면 얼굴
└── 현재 목표: 80% (기본 검증만, 고급 보정은 CIE-3)

P2 원리 우선:
└── docs/principles/image-processing.md 먼저 작성
    ├── Laplacian variance로 sharpness 측정하는 원리
    ├── 색온도 측정의 물리학적 원리
    └── 그 다음 CIE-1 구현

P3 원자 분해:
├── CIE-1.1: 해상도 검증 (1시간)
│   └── 입력: 이미지, 출력: {width, height, isValid}
├── CIE-1.2: sharpness 측정 (2시간)
│   └── 입력: 이미지, 출력: {score: 0-100}
└── CIE-1.3: 조명 분석 (2시간)
    └── 입력: 이미지, 출력: {colorTemp, evenness}

P4 단순화:
├── "해상도+sharpness+조명 외에 필요한가?" → 현재는 불필요
└── "3가지 중 제거 가능한 것?" → 없음, 모두 필수
```

---

## 이 원칙의 우선순위

```
이 문서 (00-first-principles.md)는 다른 모든 규칙보다 우선한다.

규칙 간 충돌 시:
1. 00-first-principles.md
2. 다른 .claude/rules/*.md
3. 프로젝트 관례
4. 일반적 관행

의문이 있으면 이 문서로 돌아온다.
```

---

**Version**: 3.0 | **Priority**: 최우선 (P0)
**Created**: 2026-01-15 | **Updated**: 2026-01-19
**Applies to**: 모든 작업, 예외 없음
**변경 이력**: v3.0 - P8 (모듈 경계) 추가, G7 Gate 추가 | v2.0 - P7 추가
